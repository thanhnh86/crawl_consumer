{"version":3,"sources":["../src/errors.ts","../src/cache/cache.ts","../src/events/cache_events.ts","../src/cache/locks.ts","../src/cache/factory_runner.ts","../src/cache/get_set/two_tier_handler.ts","../src/cache/get_set/single_tier_handler.ts","../src/cache/get_set/get_set_handler.ts","../src/cache/cache_stack.ts","../src/bus/bus.ts","../src/events/bus_events.ts","../src/cache/cache_entry/cache_entry_options.ts","../src/cache/tag_system.ts","../src/cache/cache_entry/cache_entry.ts","../src/cache/facades/local_cache.ts","../src/cache/facades/remote_cache.ts","../src/circuit_breaker/index.ts","../src/bento_cache_options.ts","../src/logger.ts","../src/serializers/json.ts","../src/bento_cache.ts","../src/bento_store.ts"],"sourcesContent":["import { Exception } from '@poppinss/exception'\n\n/**\n * Thrown when a factory has timed out after waiting for soft timeout\n */\nexport class FactorySoftTimeout extends Exception {\n  static code = 'E_FACTORY_SOFT_TIMEOUT'\n  static message = 'Factory has timed out after waiting for soft timeout'\n\n  key: string\n\n  constructor(key: string) {\n    super(FactorySoftTimeout.message, { code: FactorySoftTimeout.code })\n\n    this.key = key\n  }\n}\n\n/**\n * Thrown when a factory has timed out after waiting for hard timeout\n */\nexport class FactoryHardTimeout extends Exception {\n  static code = 'E_FACTORY_HARD_TIMEOUT'\n  static message = 'Factory has timed out after waiting for hard timeout'\n\n  key: string\n\n  constructor(key: string) {\n    super()\n\n    this.key = key\n  }\n}\n\n/**\n * Thrown when a factory has thrown an error. Original error is available as `cause`\n */\nexport class FactoryError extends Exception {\n  static code = 'E_FACTORY_ERROR'\n  static message = 'Factory has thrown an error'\n\n  /**\n   * The key for which the factory was called\n   */\n  key: string\n\n  /**\n   * If the error was thrown by a factory\n   * running in the background\n   */\n  isBackgroundFactory: boolean\n\n  constructor(key: string, cause: any, isBackground = false) {\n    super(FactoryError.message, { cause })\n\n    this.key = key\n    this.isBackgroundFactory = isBackground\n  }\n}\n\n/**\n * Thrown when a `undefined` value is about to be set\n * in the cache. You can't set `undefined` values.\n */\nexport class UndefinedValueError extends Exception {\n  static code = 'E_UNDEFINED_VALUE'\n\n  constructor(key: string) {\n    super(`Cannot set undefined value in the cache, key: ${key}`)\n  }\n}\n\n/**\n * Thrown when a L2 Cache operation fail\n */\nexport class L2CacheError extends Exception {\n  static code = 'E_L2_CACHE_ERROR'\n  static message = 'An error occurred while interacting with the L2 cache'\n\n  constructor(cause: any) {\n    super(L2CacheError.message, { cause })\n  }\n}\n\nexport const errors = {\n  E_FACTORY_ERROR: FactoryError,\n  E_FACTORY_SOFT_TIMEOUT: FactorySoftTimeout,\n  E_FACTORY_HARD_TIMEOUT: FactoryHardTimeout,\n  E_UNDEFINED_VALUE: UndefinedValueError,\n  E_L2_CACHE_ERROR: L2CacheError,\n}\n","import { is } from '@julr/utils/is'\n\nimport type { CacheStack } from './cache_stack.js'\nimport { CacheBusMessageType } from '../types/main.js'\nimport { cacheEvents } from '../events/cache_events.js'\nimport type { CacheProvider } from '../types/provider.js'\nimport { GetSetHandler } from './get_set/get_set_handler.js'\nimport type { BentoCacheOptions } from '../bento_cache_options.js'\nimport type {\n  Factory,\n  ClearOptions,\n  GetOrSetOptions,\n  GetOptions,\n  SetOptions,\n  HasOptions,\n  DeleteOptions,\n  DeleteManyOptions,\n  GetOrSetForeverOptions,\n  ExpireOptions,\n  DeleteByTagOptions,\n} from '../types/main.js'\n\nexport class Cache implements CacheProvider {\n  /**\n   * The name of the cache\n   */\n  name: string\n\n  #getSetHandler: GetSetHandler\n  #stack: CacheStack\n  #options: BentoCacheOptions\n\n  constructor(name: string, stack: CacheStack) {\n    this.name = name\n\n    this.#stack = stack\n    this.#options = stack.options\n    this.#getSetHandler = new GetSetHandler(this.#stack)\n    this.#stack.setTagSystemGetSetHandler(this.#getSetHandler)\n  }\n\n  #resolveDefaultValue(defaultValue?: Factory) {\n    return is.function(defaultValue) ? defaultValue() : (defaultValue ?? undefined)\n  }\n\n  /**\n   * Returns a new instance of the driver namespaced\n   */\n  namespace(namespace: string) {\n    return new Cache(this.name, this.#stack.namespace(namespace))\n  }\n\n  get<T = any>(options: GetOptions<T>): Promise<T>\n  async get<T = any>(rawOptions: GetOptions<T>): Promise<T | undefined | null> {\n    const key = rawOptions.key\n    const defaultValueFn = this.#resolveDefaultValue(rawOptions.defaultValue)\n\n    const options = this.#stack.defaultOptions.cloneWith(rawOptions)\n    this.#options.logger.logMethod({ method: 'get', key, options, cacheName: this.name })\n\n    const localItem = this.#stack.l1?.get(key, options)\n    const isLocalItemValid = await this.#stack.isEntryValid(localItem)\n    if (isLocalItemValid) {\n      this.#stack.emit(cacheEvents.hit(key, localItem!.entry.getValue(), this.name))\n      this.#options.logger.logL1Hit({ cacheName: this.name, key, options })\n      return localItem!.entry.getValue()\n    }\n\n    const remoteItem = await this.#stack.l2?.get(key, options)\n    const isRemoteItemValid = await this.#stack.isEntryValid(remoteItem)\n\n    if (isRemoteItemValid) {\n      this.#stack.l1?.set(key, remoteItem!.entry.serialize(), options)\n      this.#stack.emit(cacheEvents.hit(key, remoteItem!.entry.getValue(), this.name))\n      this.#options.logger.logL2Hit({ cacheName: this.name, key, options })\n      return remoteItem!.entry.getValue()\n    }\n\n    if (remoteItem && options.isGraceEnabled()) {\n      this.#stack.l1?.set(key, remoteItem.entry.serialize(), options)\n      this.#stack.emit(cacheEvents.hit(key, remoteItem.entry.serialize(), this.name, true))\n      this.#options.logger.logL2Hit({ cacheName: this.name, key, options, graced: true })\n      return remoteItem.entry.getValue()\n    }\n\n    if (localItem && options.isGraceEnabled()) {\n      this.#stack.emit(cacheEvents.hit(key, localItem.entry.serialize(), this.name, true))\n      this.#options.logger.logL1Hit({ cacheName: this.name, key, options, graced: true })\n      return localItem.entry.getValue()\n    }\n\n    this.#stack.emit(cacheEvents.miss(key, this.name))\n    this.#options.logger.debug({ key, cacheName: this.name }, 'cache miss. using default value')\n    return this.#resolveDefaultValue(defaultValueFn)\n  }\n\n  /**\n   * Set a value in the cache\n   * Returns true if the value was set, false otherwise\n   */\n  set(rawOptions: SetOptions) {\n    const options = this.#stack.defaultOptions.cloneWith(rawOptions)\n    this.#options.logger.logMethod({\n      method: 'set',\n      options,\n      key: rawOptions.key,\n      cacheName: this.name,\n    })\n\n    return this.#stack.set(rawOptions.key, rawOptions.value, options)\n  }\n\n  /**\n   * Set a value in the cache forever\n   * Returns true if the value was set, false otherwise\n   */\n  setForever(options: SetOptions) {\n    return this.set({ ttl: null, ...options })\n  }\n\n  /**\n   * Retrieve an item from the cache if it exists, otherwise store the value\n   * provided by the factory and return it\n   */\n  getOrSet<T>(rawOptions: GetOrSetOptions<T>): Promise<T> {\n    const options = this.#stack.defaultOptions.cloneWith(rawOptions)\n    this.#options.logger.logMethod({\n      method: 'getOrSet',\n      key: rawOptions.key,\n      cacheName: this.name,\n      options,\n    })\n\n    return this.#getSetHandler.handle(rawOptions.key, rawOptions.factory, options)\n  }\n\n  /**\n   * Retrieve an item from the cache if it exists, otherwise store the value\n   * provided by the factory forever and return it\n   */\n  getOrSetForever<T>(rawOptions: GetOrSetForeverOptions<T>): Promise<T> {\n    const options = this.#stack.defaultOptions.cloneWith({ ttl: null, ...rawOptions })\n    return this.#getSetHandler.handle(rawOptions.key, rawOptions.factory, options)\n  }\n\n  /**\n   * Check if a key exists in the cache\n   */\n  async has(options: HasOptions) {\n    const key = options.key\n    const entryOptions = this.#stack.defaultOptions.cloneWith(options)\n    this.#options.logger.logMethod({\n      method: 'has',\n      key,\n      cacheName: this.name,\n      options: entryOptions,\n    })\n\n    const localEntry = this.#stack.l1?.get(key, entryOptions)\n    const isLocalEntryValid = await this.#stack.isEntryValid(localEntry)\n    if (isLocalEntryValid) return true\n\n    const inRemote = await this.#stack.l2?.get(key, entryOptions)\n    const isRemoteEntryValid = await this.#stack.isEntryValid(inRemote)\n    if (isRemoteEntryValid) return true\n\n    return false\n  }\n\n  /**\n   * Check if key is missing in the cache\n   */\n  async missing(options: HasOptions) {\n    return !(await this.has(options))\n  }\n\n  /**\n   * Get the value of a key and delete it\n   * Returns the value if the key exists, undefined otherwise\n   */\n  async pull<T = any>(key: string): Promise<T | undefined | null> {\n    const value = await this.get<T>({ key })\n    await this.delete({ key })\n    return value\n  }\n\n  /**\n   * Delete a key from the cache, emit cache:deleted event and\n   * publish invalidation through the bus\n   */\n  async delete(rawOptions: DeleteOptions): Promise<boolean> {\n    const key = rawOptions.key\n    const options = this.#stack.defaultOptions.cloneWith(rawOptions)\n    this.#options.logger.logMethod({ method: 'delete', key, cacheName: this.name, options })\n\n    this.#stack.l1?.delete(key, options)\n    await this.#stack.l2?.delete(key, options)\n\n    this.#stack.emit(cacheEvents.deleted(key, this.name))\n    await this.#stack.publish({ type: CacheBusMessageType.Delete, keys: [key] })\n\n    return true\n  }\n\n  /**\n   * Invalidate all keys with the given tags\n   */\n  async deleteByTag(rawOptions: DeleteByTagOptions): Promise<boolean> {\n    const tags = rawOptions.tags\n    const options = this.#stack.defaultOptions.cloneWith(rawOptions)\n\n    this.#options.logger.logMethod({ method: 'deleteByTag', cacheName: this.name, tags, options })\n\n    return await this.#stack.createTagInvalidations(tags)\n  }\n\n  /**\n   * Delete multiple keys from local and remote cache\n   * Then emit cache:deleted events for each key\n   * And finally publish invalidation through the bus\n   */\n  async deleteMany(rawOptions: DeleteManyOptions): Promise<boolean> {\n    const keys = rawOptions.keys\n    const options = this.#stack.defaultOptions.cloneWith(rawOptions)\n    this.#options.logger.logMethod({\n      method: 'deleteMany',\n      key: keys,\n      cacheName: this.name,\n      options,\n    })\n\n    this.#stack.l1?.deleteMany(keys, options)\n    await this.#stack.l2?.deleteMany(keys, options)\n\n    keys.forEach((key) => this.#stack.emit(cacheEvents.deleted(key, this.name)))\n    await this.#stack.publish({ type: CacheBusMessageType.Delete, keys })\n\n    return true\n  }\n\n  /**\n   * Expire a key from the cache.\n   * Entry will not be fully deleted but expired and\n   * retained for the grace period if enabled.\n   */\n  expire(rawOptions: ExpireOptions) {\n    const key = rawOptions.key\n    const options = this.#stack.defaultOptions.cloneWith(rawOptions)\n    this.#options.logger.logMethod({ method: 'expire', cacheName: this.name, key, options })\n\n    return this.#stack.expire(key, options)\n  }\n\n  /**\n   * Remove all items from the cache\n   */\n  async clear(rawOptions?: ClearOptions) {\n    const options = this.#stack.defaultOptions.cloneWith(rawOptions)\n    this.#options.logger.logMethod({ method: 'clear', cacheName: this.name, options })\n\n    await Promise.all([\n      this.#stack.l1?.clear(),\n      this.#stack.l2?.clear(options),\n      this.#stack.publish({ type: CacheBusMessageType.Clear, keys: [] }),\n    ])\n\n    this.#stack.emit(cacheEvents.cleared(this.name))\n  }\n\n  /**\n   * Closes the connection to the cache\n   */\n  async disconnect() {\n    await Promise.all([\n      this.#stack.l1?.disconnect(),\n      this.#stack.l2?.disconnect(),\n      this.#stack.bus?.disconnect(),\n    ])\n  }\n}\n","export const cacheEvents = {\n  cleared(store: string) {\n    return {\n      name: 'cache:cleared' as const,\n      data: { store },\n    }\n  },\n  deleted(key: string, store: string) {\n    return {\n      name: 'cache:deleted' as const,\n      data: { key, store },\n    }\n  },\n  hit(key: string, value: any, store: string, graced: boolean = false) {\n    return {\n      name: 'cache:hit' as const,\n      data: { key, value, store, graced },\n    }\n  },\n  miss(key: string, store: string) {\n    return {\n      name: 'cache:miss' as const,\n      data: { key, store },\n    }\n  },\n  written(key: string, value: any, store: string) {\n    return {\n      name: 'cache:written' as const,\n      data: { key, value, store },\n    }\n  },\n  expire(key: string, store: string) {\n    return {\n      name: 'cache:expire' as const,\n      data: { key, store },\n    }\n  },\n}\n","import { is } from '@julr/utils/is'\nimport { Mutex, withTimeout, type MutexInterface } from 'async-mutex'\n\nexport class Locks {\n  /**\n   * A map that will hold active locks for each key\n   */\n  #locks = new Map<string, MutexInterface>()\n\n  /**\n   * For a given key, get or create a new lock\n   *\n   * @param key Key to get or create a lock for\n   * @param timeout Time to wait to acquire the lock\n   */\n  getOrCreateForKey(key: string, timeout?: number) {\n    let lock = this.#locks.get(key)\n    if (!lock) {\n      lock = new Mutex()\n      this.#locks.set(key, lock)\n    }\n\n    return is.number(timeout) ? withTimeout(lock, timeout) : lock\n  }\n\n  release(key: string, releaser: MutexInterface.Releaser) {\n    releaser()\n    this.#locks.delete(key)\n  }\n}\n","import pTimeout from 'p-timeout'\nimport { tryAsync } from '@julr/utils/functions'\nimport type { MutexInterface } from 'async-mutex'\n\nimport { errors } from '../errors.js'\nimport type { Locks } from './locks.js'\nimport type { CacheStack } from './cache_stack.js'\nimport type { GetSetFactory } from '../types/helpers.js'\nimport type { GetCacheValueReturn } from '../types/internals/index.js'\nimport type { CacheEntryOptions } from './cache_entry/cache_entry_options.js'\n\ninterface RunFactoryParameters {\n  key: string\n  factory: GetSetFactory\n  options: CacheEntryOptions\n  lockReleaser: MutexInterface.Releaser\n  isBackground?: boolean\n  gracedValue?: GetCacheValueReturn\n}\n\n/**\n * Factory Runner is responsible for executing factories\n */\nexport class FactoryRunner {\n  #locks: Locks\n  #stack: CacheStack\n  #skipSymbol = Symbol('bentocache.skip')\n\n  constructor(stack: CacheStack, locks: Locks) {\n    this.#stack = stack\n    this.#locks = locks\n  }\n\n  /**\n   * Process a factory error\n   */\n  #processFactoryError(params: RunFactoryParameters, error: Error | null) {\n    this.#stack.logger.warn(\n      { cache: this.#stack.name, opId: params.options.id, key: params.key, err: error },\n      'factory failed',\n    )\n\n    this.#locks.release(params.key, params.lockReleaser)\n\n    const factoryError = new errors.E_FACTORY_ERROR(params.key, error, params.isBackground)\n    params.options.onFactoryError?.(factoryError)\n\n    if (!params.isBackground) throw factoryError\n    return\n  }\n\n  async #runFactory(params: RunFactoryParameters) {\n    params.isBackground ??= false\n\n    /**\n     * Execute the factory\n     */\n    const [result, error] = await tryAsync(async () => {\n      const result = await params.factory({\n        skip: () => this.#skipSymbol as any as undefined,\n        fail: (message) => {\n          throw new Error(message ?? 'Factory failed')\n        },\n        setTtl: (ttl) => params.options.setLogicalTtl(ttl),\n        setTags: (tags) => params.options.tags.push(...tags),\n        setOptions: (options) => {\n          if (options.ttl) params.options.setLogicalTtl(options.ttl)\n          params.options.skipBusNotify = options.skipBusNotify ?? false\n          params.options.skipL2Write = options.skipL2Write ?? false\n        },\n        gracedEntry: params.gracedValue\n          ? { value: params.gracedValue?.entry.getValue() }\n          : undefined,\n      })\n\n      this.#stack.logger.info(\n        { cache: this.#stack.name, opId: params.options.id, key: params.key },\n        'factory success',\n      )\n\n      return result\n    })\n\n    if (this.#skipSymbol === result) {\n      this.#locks.release(params.key, params.lockReleaser)\n      return\n    }\n\n    /**\n     * If the factory has thrown an error, we will log it and throw a FactoryError\n     * after releasing the lock\n     */\n    if (error) return this.#processFactoryError(params, error)\n\n    /**\n     * Save the factory result in the catch\n     */\n    try {\n      await this.#stack.set(params.key, result, params.options)\n    } finally {\n      this.#locks.release(params.key, params.lockReleaser)\n    }\n\n    return result\n  }\n\n  async run(\n    key: string,\n    factory: GetSetFactory,\n    gracedValue: GetCacheValueReturn | undefined,\n    options: CacheEntryOptions,\n    lockReleaser: MutexInterface.Releaser,\n  ) {\n    const hasGracedValue = !!gracedValue\n    const timeout = options.factoryTimeout(hasGracedValue)\n    if (timeout) {\n      this.#stack.logger.info(\n        { cache: this.#stack.name, opId: options.id, key },\n        `running factory with ${timeout.type} timeout of ${timeout.duration}ms`,\n      )\n    } else {\n      this.#stack.logger.info({ cache: this.#stack.name, opId: options.id, key }, 'running factory')\n    }\n\n    /**\n     * If the timeout is 0, we will not wait for the factory to resolve\n     * And immediately return the fallback value\n     */\n    if (options.shouldSwr(hasGracedValue)) {\n      this.#runFactory({ key, factory, options, lockReleaser, isBackground: true })\n      throw new errors.E_FACTORY_SOFT_TIMEOUT(key)\n    }\n\n    const runFactory = this.#runFactory({ key, factory, options, lockReleaser, gracedValue })\n\n    const result = await pTimeout(runFactory, {\n      milliseconds: timeout?.duration ?? Number.POSITIVE_INFINITY,\n      fallback: async () => {\n        this.#stack.logger.warn(\n          { cache: this.#stack.name, opId: options.id, key },\n          `factory timed out after ${timeout?.duration}ms`,\n        )\n        throw new timeout!.exception(key)\n      },\n    })\n\n    return result\n  }\n}\n","import type { MutexInterface } from 'async-mutex'\n\nimport { Locks } from '../locks.js'\nimport { errors } from '../../errors.js'\nimport type { CacheStack } from '../cache_stack.js'\nimport { FactoryRunner } from '../factory_runner.js'\nimport type { Factory } from '../../types/helpers.js'\nimport type { CacheEvent } from '../../types/events.js'\nimport { cacheEvents } from '../../events/cache_events.js'\nimport type { GetCacheValueReturn } from '../../types/internals/index.js'\nimport type { CacheEntryOptions } from '../cache_entry/cache_entry_options.js'\n\nexport class TwoTierHandler {\n  /**\n   * A map that will hold active locks for each key\n   */\n  #locks = new Locks()\n  #factoryRunner: FactoryRunner\n\n  constructor(protected stack: CacheStack) {\n    this.#factoryRunner = new FactoryRunner(this.stack, this.#locks)\n  }\n\n  get logger() {\n    return this.stack.logger\n  }\n\n  /**\n   * Emit a CacheEvent using the emitter\n   */\n  #emit(event: CacheEvent) {\n    return this.stack.emitter.emit(event.name, event.data)\n  }\n\n  /**\n   * Returns a value from the local cache and emit a CacheHit event\n   */\n  #returnL1Value(key: string, item: GetCacheValueReturn) {\n    this.#emit(cacheEvents.hit(key, item.entry.getValue(), this.stack.name, item.isGraced))\n    return item.entry.getValue()\n  }\n\n  /**\n   * Returns a value from the remote cache and emit a CacheHit event\n   */\n  async #returnRemoteCacheValue(\n    key: string,\n    item: GetCacheValueReturn,\n    options: CacheEntryOptions,\n  ) {\n    this.stack.l1?.set(key, item.entry.serialize(), options)\n\n    this.#emit(cacheEvents.hit(key, item.entry.getValue(), this.stack.name))\n    return item.entry.getValue()\n  }\n\n  /**\n   * Try acquiring a lock for a key\n   *\n   * If we have a fallback value, grace period enabled, and a soft timeout configured\n   * we will wait at most the soft timeout to acquire the lock\n   */\n  #acquireLock(key: string, hasFallback: boolean, options: CacheEntryOptions) {\n    const lock = this.#locks.getOrCreateForKey(key, options.getApplicableLockTimeout(hasFallback))\n    return lock.acquire()\n  }\n\n  #returnGracedValueOrThrow(\n    key: string,\n    item: GetCacheValueReturn | undefined,\n    options: CacheEntryOptions,\n    err: Error,\n  ) {\n    if (options.isGraceEnabled() && item) return this.#returnL1Value(key, item)\n    throw err\n  }\n\n  async #applyFallbackAndReturnGracedValue(\n    key: string,\n    item: GetCacheValueReturn,\n    options: CacheEntryOptions,\n  ) {\n    if (options.grace && options.graceBackoff) {\n      this.logger.trace(\n        { key, cache: this.stack.name, opId: options.id },\n        'apply fallback duration',\n      )\n\n      this.stack.l1?.set(key, item.entry.applyBackoff(options.graceBackoff).serialize(), options)\n    }\n\n    this.logger.trace({ key, cache: this.stack.name, opId: options.id }, 'returns stale value')\n    this.#emit(cacheEvents.hit(key, item.entry.getValue(), this.stack.name, true))\n    return item.entry.getValue()\n  }\n\n  async #lockAndHandle(\n    key: string,\n    factory: Factory,\n    options: CacheEntryOptions,\n    localItem?: GetCacheValueReturn,\n  ) {\n    /**\n     * Since we didn't find a valid item in the local cache, we need to\n     * check the remote cache, or invoke the factory.\n     *\n     * We acquire a lock to prevent a cache stampede.\n     */\n    let releaser: MutexInterface.Releaser\n    try {\n      this.logger.trace({ key, cache: this.stack.name, opId: options.id }, 'acquiring lock...')\n      releaser = await this.#acquireLock(key, !!localItem, options)\n    } catch (err) {\n      this.logger.trace({ key, cache: this.stack.name, opId: options.id }, 'lock failed')\n      return this.#returnGracedValueOrThrow(key, localItem, options, err)\n    }\n\n    this.logger.trace({ key, cache: this.stack.name, opId: options.id }, 'acquired lock')\n\n    let remoteItem\n    if (!options.forceFresh) {\n      /**\n       * Check local cache again, as another process could have written a value\n       * while we were waiting for the lock.\n       */\n      localItem = this.stack.l1?.get(key, options)\n      const isLocalItemValid = await this.stack.isEntryValid(localItem)\n      if (isLocalItemValid) {\n        this.#locks.release(key, releaser)\n        return this.#returnL1Value(key, localItem!)\n      }\n\n      /**\n       * Check remote cache in case something was written there\n       */\n      remoteItem = await this.stack.l2?.get(key, options)\n      const isRemoteItemValid = await this.stack.isEntryValid(remoteItem)\n      if (isRemoteItemValid) {\n        this.#locks.release(key, releaser)\n        return this.#returnRemoteCacheValue(key, remoteItem!, options)\n      }\n    }\n\n    try {\n      const gracedValue = localItem || remoteItem\n      const result = await this.#factoryRunner.run(key, factory, gracedValue, options, releaser)\n      this.#emit(cacheEvents.miss(key, this.stack.name))\n\n      return result\n    } catch (err) {\n      /**\n       * If we hit a soft timeout and we have a graced value, returns it\n       */\n      const staleItem = remoteItem ?? localItem\n      if (err instanceof errors.E_FACTORY_SOFT_TIMEOUT && staleItem) {\n        return this.#returnGracedValueOrThrow(key, staleItem, options, err)\n      }\n\n      /**\n       * Otherwise, that means we had a factory error. If we have a graced\n       * value, returns it\n       */\n      this.logger.trace({ key, cache: this.stack.name, opId: options.id, err }, 'factory error')\n\n      if (staleItem && options.isGraceEnabled()) {\n        this.#locks.release(key, releaser)\n        return this.#applyFallbackAndReturnGracedValue(key, staleItem, options)\n      }\n\n      this.#locks.release(key, releaser)\n      throw err\n    }\n  }\n\n  handle(key: string, factory: Factory, options: CacheEntryOptions) {\n    if (options.forceFresh) return this.#lockAndHandle(key, factory, options)\n\n    /**\n     * First we check the local cache. If we have a valid item, just\n     * returns it without acquiring a lock.\n     */\n    const localItem = this.stack.l1?.get(key, options)\n    const isLocalItemValid = this.stack.isEntryValid(localItem)\n\n    // A bit nasty, but to keep maximum performance, we avoid async/await here.\n    // Let's check for a better way to handle this later.\n    if (isLocalItemValid instanceof Promise) {\n      return isLocalItemValid.then((valid) => {\n        if (valid) return this.#returnL1Value(key, localItem!)\n        return this.#lockAndHandle(key, factory, options, localItem)\n      })\n    }\n\n    if (isLocalItemValid) return this.#returnL1Value(key, localItem!)\n\n    /**\n     * Next, delegate to the lock-and-handle async method so we can keep\n     * this method synchronous and avoid an overhead of async/await\n     * in case we have a valid item in the local cache.\n     */\n    return this.#lockAndHandle(key, factory, options, localItem)\n  }\n}\n","import type { MutexInterface } from 'async-mutex'\n\nimport { Locks } from '../locks.js'\nimport { errors } from '../../errors.js'\nimport type { CacheStack } from '../cache_stack.js'\nimport { FactoryRunner } from '../factory_runner.js'\nimport type { Factory } from '../../types/helpers.js'\nimport type { CacheEvent } from '../../types/events.js'\nimport { cacheEvents } from '../../events/cache_events.js'\nimport type { GetCacheValueReturn } from '../../types/internals/index.js'\nimport type { CacheEntryOptions } from '../cache_entry/cache_entry_options.js'\n\nexport class SingleTierHandler {\n  /**\n   * A map that will hold active locks for each key\n   */\n  #locks = new Locks()\n  #factoryRunner: FactoryRunner\n\n  constructor(protected stack: CacheStack) {\n    this.#factoryRunner = new FactoryRunner(this.stack, this.#locks)\n  }\n\n  get logger() {\n    return this.stack.logger\n  }\n\n  /**\n   * Emit a CacheEvent using the emitter\n   */\n  #emit(event: CacheEvent) {\n    return this.stack.emitter.emit(event.name, event.data)\n  }\n\n  /**\n   * Returns a value from the remote cache and emit a CacheHit event\n   */\n  async #returnRemoteCacheValue(\n    key: string,\n    item: GetCacheValueReturn,\n    options: CacheEntryOptions,\n  ) {\n    this.logger.logL2Hit({ cacheName: this.stack.name, key, options })\n\n    this.#emit(cacheEvents.hit(key, item.entry.getValue(), this.stack.name))\n    return item.entry.getValue()\n  }\n\n  /**\n   * Try acquiring a lock for a key\n   *\n   * If we have a fallback value, grace period enabled, and a soft timeout configured\n   * we will wait at most the soft timeout to acquire the lock\n   */\n  #acquireLock(key: string, hasFallback: boolean, options: CacheEntryOptions) {\n    const lock = this.#locks.getOrCreateForKey(key, options.getApplicableLockTimeout(hasFallback))\n    return lock.acquire()\n  }\n\n  #returnGracedValueOrThrow(\n    key: string,\n    item: GetCacheValueReturn | undefined,\n    options: CacheEntryOptions,\n    err: Error,\n  ) {\n    if (options.isGraceEnabled() && item) {\n      this.#emit(cacheEvents.hit(key, item.entry.getValue(), this.stack.name, item.isGraced))\n      return item.entry.getValue()\n    }\n\n    throw err\n  }\n\n  async #applyFallbackAndReturnGracedValue(\n    key: string,\n    item: GetCacheValueReturn,\n    options: CacheEntryOptions,\n  ) {\n    if (options.grace && options.graceBackoff) {\n      this.logger.trace(\n        { key, cache: this.stack.name, opId: options.id },\n        'apply fallback duration',\n      )\n\n      this.stack.l2?.set(\n        key,\n        item.entry.applyBackoff(options.graceBackoff).serialize() as any,\n        options,\n      )\n    }\n\n    this.logger.trace({ key, cache: this.stack.name, opId: options.id }, 'returns stale value')\n    this.#emit(cacheEvents.hit(key, item.entry.getValue(), this.stack.name, true))\n    return item.entry.getValue()\n  }\n\n  async handle(key: string, factory: Factory, options: CacheEntryOptions) {\n    /**\n     * If forceFresh is not true, check in the remote cache first\n     */\n    let remoteItem: GetCacheValueReturn | undefined\n    let isRemoteItemValid = false\n\n    if (!options.forceFresh) {\n      remoteItem = await this.stack.l2?.get(key, options)\n      isRemoteItemValid = await this.stack.isEntryValid(remoteItem)\n      if (isRemoteItemValid) {\n        return this.#returnRemoteCacheValue(key, remoteItem!, options)\n      }\n    }\n\n    /**\n     * If nothing is found in the remote cache, or if forceFresh is true,\n     * we try to acquire a lock to run the factory\n     */\n    let releaser: MutexInterface.Releaser\n    try {\n      releaser = await this.#acquireLock(key, !!remoteItem, options)\n    } catch (err) {\n      return this.#returnGracedValueOrThrow(key, remoteItem, options, err)\n    }\n\n    /**\n     * If not forceFresh, check in the remote cache again, in case another process\n     * already set the value\n     */\n    if (!options.forceFresh) {\n      remoteItem = await this.stack.l2?.get(key, options)\n      isRemoteItemValid = await this.stack.isEntryValid(remoteItem)\n      if (isRemoteItemValid) {\n        this.#locks.release(key, releaser)\n        return this.#returnRemoteCacheValue(key, remoteItem!, options)\n      }\n    }\n\n    try {\n      const result = await this.#factoryRunner.run(key, factory, remoteItem, options, releaser)\n      this.#emit(cacheEvents.miss(key, this.stack.name))\n      return result\n    } catch (err) {\n      /**\n       * If we hit a soft timeout and we have a graced value, returns it\n       */\n      const staleItem = remoteItem\n      if (err instanceof errors.E_FACTORY_SOFT_TIMEOUT && staleItem) {\n        return this.#returnGracedValueOrThrow(key, staleItem, options, err)\n      }\n\n      /**\n       * Otherwise, that means we had a factory error. If we have a graced\n       * value, returns it\n       */\n      this.logger.trace({ key, cache: this.stack.name, opId: options.id, err }, 'factory error')\n\n      if (staleItem && options.isGraceEnabled()) {\n        this.#locks.release(key, releaser)\n        return this.#applyFallbackAndReturnGracedValue(key, staleItem, options)\n      }\n\n      this.#locks.release(key, releaser)\n      throw err\n    }\n  }\n}\n","import type { CacheStack } from '../cache_stack.js'\nimport type { Factory } from '../../types/helpers.js'\nimport { TwoTierHandler } from './two_tier_handler.js'\nimport { SingleTierHandler } from './single_tier_handler.js'\nimport type { CacheEntryOptions } from '../cache_entry/cache_entry_options.js'\n\nexport class GetSetHandler {\n  #singleTierHandler: SingleTierHandler\n  #twoTierHandler: TwoTierHandler\n\n  constructor(private stack: CacheStack) {\n    this.#twoTierHandler = new TwoTierHandler(this.stack)\n    this.#singleTierHandler = new SingleTierHandler(this.stack)\n  }\n\n  /**\n   * In the case where we have an L1 and an L2, the flow is quite different\n   * from the one where we only have an L2.\n   *\n   * Therefore we come here to determine which handler to use\n   * depending on the configuration of the stack.\n   */\n  handle(key: string, factory: Factory, options: CacheEntryOptions) {\n    if (this.stack.l2 && !this.stack.l1) {\n      return this.#singleTierHandler.handle(key, factory, options)\n    }\n\n    return this.#twoTierHandler.handle(key, factory, options)\n  }\n}\n","import { is } from '@julr/utils/is'\n\nimport { Bus } from '../bus/bus.js'\nimport type { Logger } from '../logger.js'\nimport { TagSystem } from './tag_system.js'\nimport { UndefinedValueError } from '../errors.js'\nimport { LocalCache } from './facades/local_cache.js'\nimport { BaseDriver } from '../drivers/base_driver.js'\nimport { RemoteCache } from './facades/remote_cache.js'\nimport { cacheEvents } from '../events/cache_events.js'\nimport type { GetSetHandler } from './get_set/get_set_handler.js'\nimport type { BentoCacheOptions } from '../bento_cache_options.js'\nimport type { GetCacheValueReturn } from '../types/internals/index.js'\nimport type { CacheEntryOptions } from './cache_entry/cache_entry_options.js'\nimport { createCacheEntryOptions } from './cache_entry/cache_entry_options.js'\nimport {\n  type BusDriver,\n  type BusOptions,\n  type CacheEvent,\n  type CacheStackDrivers,\n  type CacheBusMessage,\n  CacheBusMessageType,\n} from '../types/main.js'\n\nexport class CacheStack extends BaseDriver {\n  l1?: LocalCache\n  l2?: RemoteCache\n  bus?: Bus\n  defaultOptions: ReturnType<typeof createCacheEntryOptions>\n  logger: Logger\n  #busDriver?: BusDriver\n  #busOptions?: BusOptions\n  #tagSystem: TagSystem\n  #namespaceCache: Map<string, CacheStack> = new Map()\n\n  constructor(\n    public name: string,\n    public options: BentoCacheOptions,\n    drivers: CacheStackDrivers,\n    bus?: Bus,\n  ) {\n    super(options)\n    this.logger = options.logger.child({ cache: this.name })\n\n    if (drivers.l1Driver)\n      this.l1 = new LocalCache(\n        drivers.l1Driver,\n        this.logger,\n        this.options.serializeL1 ? this.options.serializer : undefined,\n      )\n    if (drivers.l2Driver)\n      this.l2 = new RemoteCache(drivers.l2Driver, this.logger, !!this.l1, this.options)\n\n    this.bus = bus ? bus : this.#createBus(drivers.busDriver, drivers.busOptions)\n    if (this.l1) this.bus?.manageCache(this.prefix, this.l1)\n\n    this.#tagSystem = new TagSystem(this)\n    this.defaultOptions = createCacheEntryOptions(this.options)\n  }\n\n  get emitter() {\n    return this.options.emitter\n  }\n\n  #createBus(busDriver?: BusDriver, busOptions?: BusOptions) {\n    if (!busDriver) return\n\n    this.#busDriver = busDriver\n    this.#busOptions = {\n      retryQueue: { enabled: true, maxSize: undefined },\n      ...busOptions,\n    }\n\n    return new Bus(this.name, this.#busDriver, this.logger, this.emitter, this.#busOptions)\n  }\n\n  setTagSystemGetSetHandler(getSetHandler: GetSetHandler) {\n    this.#tagSystem.setGetSetHandler(getSetHandler)\n  }\n\n  namespace(namespace: string): CacheStack {\n    if (!this.#namespaceCache.has(namespace)) {\n      this.#namespaceCache.set(\n        namespace,\n        new CacheStack(\n          this.name,\n          this.options.cloneWith({ prefix: this.createNamespacePrefix(namespace) }),\n          {\n            l1Driver: this.l1?.namespace(namespace),\n            l2Driver: this.l2?.namespace(namespace),\n          },\n          this.bus,\n        ),\n      )\n    }\n\n    return <CacheStack>this.#namespaceCache.get(namespace)\n  }\n\n  /**\n   * Publish a message to the bus channel\n   *\n   * @returns true if the message was published, false if not\n   * and undefined if a bus is not part of the stack\n   */\n  async publish(\n    message: CacheBusMessage,\n    options?: CacheEntryOptions,\n  ): Promise<boolean | undefined> {\n    if (options?.skipBusNotify) return\n\n    return this.bus?.publish({ ...message, namespace: this.prefix })\n  }\n\n  emit(event: CacheEvent) {\n    return this.emitter.emit(event.name, event.data)\n  }\n\n  /**\n   * Write a value in the cache stack\n   * - Set value in local cache\n   * - Set value in remote cache\n   * - Publish a message to the bus\n   * - Emit a CacheWritten event\n   */\n  async set(key: string, value: any, options: CacheEntryOptions) {\n    if (is.undefined(value)) throw new UndefinedValueError(key)\n\n    const rawItem = {\n      value,\n      logicalExpiration: options.logicalTtlFromNow(),\n      tags: options.tags,\n      createdAt: Date.now(),\n    }\n\n    /**\n     * Store raw or serialized value in the local cache based on the serializeL1 option\n     */\n    const l1Item = this.options.serializeL1 ? this.options.serializer.serialize(rawItem) : rawItem\n    this.l1?.set(key, l1Item, options)\n\n    /**\n     * Store the serialized value in the remote cache\n     */\n    let l2Success = false\n    if (this.l2 && options.skipL2Write !== true) {\n      const l2Item = this.options.serializeL1 ? l1Item : this.options.serializer.serialize(rawItem)\n      l2Success = await this.l2?.set(key, l2Item as any, options)\n    }\n\n    /**\n     * Publish only if the remote cache write was successful.\n     */\n    if ((this.l2 && l2Success) || !this.l2) {\n      await this.publish({ type: CacheBusMessageType.Set, keys: [key] }, options)\n    }\n\n    this.emit(cacheEvents.written(key, value, this.name))\n    return true\n  }\n\n  /**\n   * Expire a key from the cache.\n   * Entry will not be fully deleted but expired and\n   * retained for the grace period if enabled.\n   */\n  async expire(key: string, options: CacheEntryOptions) {\n    this.l1?.logicallyExpire(key, options)\n    await this.l2?.logicallyExpire(key, options)\n    await this.publish({ type: CacheBusMessageType.Expire, keys: [key] })\n\n    this.emit(cacheEvents.expire(key, this.name))\n    return true\n  }\n\n  /**\n   * Check if an item is valid.\n   * Valid means :\n   * - Logically not expired ( not graced )\n   * - Not invalidated by a tag\n   */\n  isEntryValid(item: GetCacheValueReturn | undefined): Promise<boolean> | boolean {\n    if (!item) return false\n\n    const isGraced = item?.isGraced === true\n    if (isGraced) return false\n\n    if (item.entry.getTags().length === 0) return true\n\n    return this.#tagSystem.isTagInvalidated(item.entry).then((isTagInvalidated) => {\n      return !isTagInvalidated\n    })\n  }\n\n  /**\n   * Create invalidation keys for a list of tags\n   */\n  async createTagInvalidations(tags: string[]) {\n    return this.#tagSystem.createTagInvalidations(tags)\n  }\n}\n","import { Bus as BoringBus } from '@boringnode/bus'\nimport type { Transport } from '@boringnode/bus/types/main'\n\nimport type { Logger } from '../logger.js'\nimport { busEvents } from '../events/bus_events.js'\nimport { CacheBusMessageType } from '../types/bus.js'\nimport type { LocalCache } from '../cache/facades/local_cache.js'\nimport type { BusOptions, CacheBusMessage, Emitter } from '../types/main.js'\n\n/**\n * The bus is used to notify other processes about cache changes.\n * We use an underlying bus driver to send and receive messages.\n *\n * So basically, when a cache entry is set or deleted, we publish\n * a message to the bus channel. Other processes are subscribed to\n * the same channel and will receive the message and update their\n * local cache accordingly.\n */\nexport class Bus {\n  #bus: BoringBus\n  #logger: Logger\n  #emitter: Emitter\n  #localCaches: Map<string, LocalCache> = new Map()\n  #channelName = 'bentocache.notifications'\n\n  constructor(\n    name: string,\n    driver: Transport,\n    logger: Logger,\n    emitter: Emitter,\n    options: BusOptions = {},\n  ) {\n    this.#emitter = emitter\n    this.#logger = logger.child({ context: 'bentocache.bus' })\n\n    this.#bus = new BoringBus(driver, {\n      retryQueue: {\n        ...options.retryQueue,\n        removeDuplicates: true,\n        retryInterval: options.retryQueue?.retryInterval ?? 2000,\n      },\n    })\n\n    if (name) this.#channelName += `:${name}`\n\n    this.#bus.subscribe<CacheBusMessage>(this.#channelName, this.#onMessage.bind(this))\n    this.#logger.trace({ channel: this.#channelName }, 'bus subscribed to channel')\n  }\n\n  /**\n   * Add a LocalCache for this bus to manage\n   * @param namespace The namespace\n   * @param cache The LocalCache instance\n   */\n  manageCache(namespace: string, cache: LocalCache) {\n    this.#logger.trace({ namespace, channel: this.#channelName }, 'added namespaced cache')\n    this.#localCaches?.set(namespace, cache)\n  }\n\n  /**\n   * When a message is received through the bus.\n   * This is where we update the local cache.\n   */\n  async #onMessage(message: CacheBusMessage) {\n    if (!message.namespace || !this.#localCaches.has(message.namespace)) return\n\n    this.#logger.trace({ ...message, channel: this.#channelName }, 'received message from bus')\n    this.#emitter.emit('bus:message:received', busEvents.messageReceived(message).data)\n\n    const cache = this.#localCaches.get(message.namespace)\n\n    if (message.type === CacheBusMessageType.Delete) {\n      for (const key of message.keys) cache?.delete(key)\n    }\n\n    if (message.type === CacheBusMessageType.Set) {\n      for (const key of message.keys) cache?.logicallyExpire(key)\n    }\n\n    if (message.type === CacheBusMessageType.Expire) {\n      for (const key of message.keys) cache?.logicallyExpire(key)\n    }\n\n    if (message.type === CacheBusMessageType.Clear) {\n      cache?.clear()\n    }\n  }\n\n  /**\n   * Publish a message to the bus channel\n   *\n   * @returns true if the message was published, false if not\n   */\n  async publish(message: CacheBusMessage): Promise<boolean> {\n    const wasPublished = await this.#bus.publish(this.#channelName, message)\n    if (wasPublished) {\n      this.#emitter.emit('bus:message:published', busEvents.messagePublished(message).data)\n      return true\n    }\n\n    this.#logger.error('failed to publish message to bus')\n    return false\n  }\n\n  /**\n   * Disconnect the bus\n   */\n  async disconnect(): Promise<void> {\n    await this.#bus.disconnect()\n  }\n}\n","import type { CacheBusMessage } from '../types/bus.js'\n\nexport const busEvents = {\n  messagePublished(message: CacheBusMessage) {\n    return {\n      name: 'bus:message:published',\n      data: { message: { keys: message.keys, type: message.type } },\n    }\n  },\n  messageReceived(message: CacheBusMessage) {\n    return {\n      name: 'bus:message:received',\n      data: { message: { keys: message.keys, type: message.type } },\n    }\n  },\n}\n","import { is } from '@julr/utils/is'\n\nimport { errors } from '../../errors.js'\nimport { hexoid, resolveTtl } from '../../helpers.js'\nimport type { Duration, RawCommonOptions } from '../../types/main.js'\n\nconst toId = hexoid(12)\n\nexport type CacheEntryOptions = ReturnType<typeof createCacheEntryOptions>\n\n/**\n * Resolve the grace options\n */\nfunction resolveGrace(options: RawCommonOptions) {\n  if (options.grace === false) return 0\n\n  return resolveTtl(options.grace, null) ?? 0\n}\n\n/**\n * Cache Entry Options. Define how a cache operation should behave\n *\n * Yes, this is a fake class. Initially, this was a class, but\n * since CacheEntryOptions is initialized each time a cache\n * operation is performed, it was converted to this\n * fake class to have way better performance.\n */\nexport function createCacheEntryOptions(\n  newOptions: RawCommonOptions = {},\n  defaults: Partial<RawCommonOptions> = {},\n) {\n  const options = { ...defaults, ...newOptions }\n\n  const grace = resolveGrace(options)\n  const graceBackoff = resolveTtl(options.graceBackoff, null) ?? 0\n\n  let logicalTtl = resolveTtl(options.ttl)\n  let physicalTtl = grace > 0 ? grace : logicalTtl\n\n  const timeout = resolveTtl(options.timeout, null)\n  const hardTimeout = resolveTtl(options.hardTimeout, null)\n  const lockTimeout = resolveTtl(options.lockTimeout, null)\n  const forceFresh = options.forceFresh ?? false\n\n  const self = {\n    /**\n     * Unique identifier that will be used when logging\n     * debug information.\n     */\n    id: toId(),\n\n    /**\n     * Resolved grace period options\n     */\n    grace,\n    graceBackoff,\n\n    /**\n     * Logical TTL is when the value is considered expired\n     * but still can be in the cache ( Grace period )\n     */\n    getLogicalTtl() {\n      return logicalTtl\n    },\n\n    /**\n     * Physical TTL is the time when value will be automatically\n     * removed from the cache. This is the Grace period\n     * duration\n     */\n    getPhysicalTtl() {\n      return physicalTtl\n    },\n\n    /**\n     * Determine if the gracing system is enabled\n     */\n    isGraceEnabled() {\n      return grace > 0\n    },\n\n    /**\n     * Timeouts for the cache operations\n     */\n    timeout,\n    hardTimeout,\n\n    /**\n     * Tags to associate with the cache entry\n     */\n    tags: options.tags ?? [],\n\n    /**\n     * Skip options\n     */\n    skipL2Write: options.skipL2Write ?? false,\n    skipBusNotify: options.skipBusNotify ?? false,\n\n    /**\n     * Max time to wait for the lock to be acquired\n     */\n    lockTimeout,\n    onFactoryError: options.onFactoryError ?? defaults.onFactoryError,\n    suppressL2Errors: options.suppressL2Errors,\n\n    /**\n     * Force fresh option\n     */\n    forceFresh,\n\n    /**\n     * Returns a new instance of `CacheItemOptions` with the same\n     * options as the current instance, but with any provided\n     * options overriding the current\n     *\n     * For performance reasons, if no options are provided, the\n     * current instance is returned\n     */\n    cloneWith(newOptions?: Partial<RawCommonOptions>) {\n      return newOptions ? createCacheEntryOptions(newOptions, options) : self\n    },\n\n    /**\n     * Set a new logical TTL\n     */\n    setLogicalTtl(newTtl: Duration) {\n      options.ttl = newTtl\n\n      logicalTtl = resolveTtl(options.ttl)\n      physicalTtl = self.isGraceEnabled() ? grace : logicalTtl\n\n      return self\n    },\n\n    /**\n     * Compute the logical TTL timestamp from now\n     */\n    logicalTtlFromNow() {\n      if (!logicalTtl) return\n\n      return Date.now() + logicalTtl\n    },\n\n    /**\n     * Compute the physical TTL timestamp from now\n     */\n    physicalTtlFromNow() {\n      if (!physicalTtl) return\n\n      return Date.now() + physicalTtl\n    },\n\n    /**\n     * Compute the lock timeout we should use for the\n     * factory\n     */\n    factoryTimeout(hasFallbackValue: boolean) {\n      if (hasFallbackValue && self.isGraceEnabled() && is.number(timeout)) {\n        return { type: 'soft', duration: timeout, exception: errors.E_FACTORY_SOFT_TIMEOUT }\n      }\n\n      if (hardTimeout) {\n        return { type: 'hard', duration: hardTimeout, exception: errors.E_FACTORY_HARD_TIMEOUT }\n      }\n    },\n\n    /**\n     * Determine if we should use the SWR strategy\n     */\n    shouldSwr(hasFallback: boolean) {\n      return self.isGraceEnabled() && timeout === 0 && hasFallback\n    },\n\n    /**\n     * Compute the maximum time we should wait for the\n     * lock to be acquired\n     */\n    getApplicableLockTimeout(hasFallbackValue: boolean) {\n      if (lockTimeout) return lockTimeout\n\n      /**\n       * If we have a fallback value and grace period is enabled,\n       * that means we should wait at most for the soft timeout\n       * duration.\n       */\n      if (hasFallbackValue && self.isGraceEnabled() && typeof timeout === 'number') {\n        return timeout\n      }\n    },\n  }\n\n  return self\n}\n","import type { CacheStack } from './cache_stack.js'\nimport type { CacheEntry } from './cache_entry/cache_entry.js'\nimport type { GetSetFactoryContext } from '../types/helpers.js'\nimport type { GetSetHandler } from './get_set/get_set_handler.js'\nimport { createCacheEntryOptions } from './cache_entry/cache_entry_options.js'\n\nexport class TagSystem {\n  #getSetHandler!: GetSetHandler\n  #kTagPrefix = '___bc:t:'\n\n  #expireOptions = createCacheEntryOptions({})\n  #getSetTagOptions = createCacheEntryOptions({\n    ttl: '10d',\n    grace: '10d',\n  })\n\n  constructor(private stack: CacheStack) {}\n\n  setGetSetHandler(handler: GetSetHandler) {\n    this.#getSetHandler = handler\n  }\n\n  /**\n   * Get the cache key for a tag\n   */\n  getTagCacheKey(tag: string) {\n    return this.#kTagPrefix + tag\n  }\n\n  /**\n   * Check if a key is a tag key\n   */\n  isTagKey(key: string) {\n    return key.startsWith(this.#kTagPrefix)\n  }\n\n  /**\n   * The GetSet factory when getting a tag from the cache.\n   */\n  #getTagFactory(ctx: GetSetFactoryContext) {\n    const result = ctx.gracedEntry?.value ?? 0\n    if (result === 0) ctx.setOptions({ skipBusNotify: true, skipL2Write: true })\n\n    return result\n  }\n\n  /**\n   * Check if an entry is invalidated by a tag and return true if it is.\n   */\n  async isTagInvalidated(entry?: CacheEntry) {\n    if (!entry) return\n    if (this.isTagKey(entry.getKey())) return false\n\n    const tags = entry.getTags()\n    if (!tags.length) return false\n\n    for (const tag of tags) {\n      const tagExpiration = await this.#getSetHandler.handle(\n        this.getTagCacheKey(tag),\n        this.#getTagFactory,\n        this.#getSetTagOptions.cloneWith({}),\n      )\n\n      if (entry.getCreatedAt() <= tagExpiration) {\n        await this.stack.expire(entry.getKey(), this.#expireOptions)\n        return true\n      }\n    }\n  }\n\n  /**\n   * Create invalidation keys for a list of tags\n   *\n   * We write a `__bc:t:<tag>` key with the current timestamp as value.\n   * When we check if a key is invalidated by a tag, we check if the key\n   * was created before the tag key value.\n   */\n  async createTagInvalidations(tags: string[]) {\n    const now = Date.now()\n\n    for (const tag of new Set(tags)) {\n      const key = this.getTagCacheKey(tag)\n      await this.stack.set(key, now, this.#getSetTagOptions)\n    }\n\n    return true\n  }\n}\n","import type { CacheSerializer } from '../../types/main.js'\n\n/**\n * Represents a cache entry stored inside a cache driver.\n */\nexport class CacheEntry {\n  /**\n   * The key of the cache item.\n   */\n  #key: string\n\n  /**\n   * The value of the item.\n   */\n  #value: any\n  #tags: string[]\n\n  /**\n   * The logical expiration is the time in miliseconds when the item\n   * will be considered expired. But, if grace period is enabled,\n   * the item will still be available for a while.\n   */\n  #logicalExpiration: number\n\n  /**\n   * The time when the item was created.\n   */\n  #createdAt: number\n\n  #serializer?: CacheSerializer\n\n  constructor(key: string, item: Record<string, any>, serializer?: CacheSerializer) {\n    this.#key = key\n    this.#value = item.value\n    this.#tags = item.tags ?? []\n    this.#logicalExpiration = item.logicalExpiration\n    this.#serializer = serializer\n    this.#createdAt = item.createdAt\n  }\n\n  getValue() {\n    return this.#value\n  }\n\n  getKey() {\n    return this.#key\n  }\n\n  getCreatedAt() {\n    return this.#createdAt\n  }\n\n  getLogicalExpiration() {\n    return this.#logicalExpiration\n  }\n\n  getTags() {\n    return this.#tags\n  }\n\n  isLogicallyExpired() {\n    return Date.now() >= this.#logicalExpiration\n  }\n\n  static fromDriver(key: string, item: string | Record<string, any>, serializer?: CacheSerializer) {\n    if (!serializer && typeof item !== 'string') return new CacheEntry(key, item, serializer)\n\n    return new CacheEntry(key, serializer!.deserialize(item) ?? item, serializer)\n  }\n\n  applyBackoff(duration: number) {\n    this.#logicalExpiration += duration\n    return this\n  }\n\n  expire() {\n    this.#logicalExpiration = Date.now() - 100\n    return this\n  }\n\n  serialize() {\n    const raw = {\n      value: this.#value,\n      createdAt: this.#createdAt,\n      logicalExpiration: this.#logicalExpiration,\n      ...(this.#tags.length > 0 && { tags: this.#tags }),\n    }\n\n    if (this.#serializer) return this.#serializer.serialize(raw)\n    return raw\n  }\n}\n","import type { Logger } from '../../logger.js'\nimport { CacheEntry } from '../cache_entry/cache_entry.js'\nimport type { L1CacheDriver, CacheSerializer } from '../../types/main.js'\nimport type { CacheEntryOptions } from '../cache_entry/cache_entry_options.js'\n\n/**\n * LocalCache is a wrapper around a CacheDriver that provides a\n * some handy methods for interacting with a local cache ( in-memory )\n */\nexport class LocalCache {\n  #driver: L1CacheDriver\n  #logger: Logger\n  #serializer: CacheSerializer | undefined\n\n  constructor(driver: L1CacheDriver, logger: Logger, serializer: CacheSerializer | undefined) {\n    this.#driver = driver\n    this.#serializer = serializer\n    this.#logger = logger.child({ layer: 'l1' })\n  }\n\n  /**\n   * Get an item from the local cache\n   */\n  get(key: string, options: CacheEntryOptions) {\n    /**\n     * Try to get the item from the local cache\n     */\n    this.#logger.trace({ key, opId: options.id }, 'try getting from l1 cache')\n    const value = this.#driver.get(key)\n\n    /**\n     * If the item is not found, return undefined\n     */\n    if (value === undefined) {\n      this.#logger.debug({ key, opId: options.id }, 'cache miss')\n      return\n    }\n\n    const entry = CacheEntry.fromDriver(key, value, this.#serializer)\n    const isGraced = entry.isLogicallyExpired()\n    if (isGraced) {\n      this.#logger.debug({ key, opId: options.id }, 'cache hit (graced)')\n    } else {\n      this.#logger.debug({ key, opId: options.id }, 'cache hit')\n    }\n\n    return { entry, isGraced }\n  }\n\n  /**\n   * Set a new item in the local cache\n   */\n  set(key: string, value: any, options: CacheEntryOptions) {\n    /**\n     * If grace period is disabled and Physical TTL is 0 or less, we can just delete the item.\n     */\n    const physicalTtl = options.getPhysicalTtl()\n    if (!options.isGraceEnabled() && physicalTtl && physicalTtl <= 0) {\n      return this.delete(key, options)\n    }\n\n    /**\n     * Save the item to the local cache\n     */\n    this.#logger.debug({ key, opId: options.id }, 'saving item')\n    this.#driver.set(key, value, physicalTtl)\n  }\n\n  /**\n   * Delete an item from the local cache\n   */\n  delete(key: string, options?: CacheEntryOptions) {\n    this.#logger.debug({ key, opId: options?.id }, 'deleting item')\n    return this.#driver.delete(key)\n  }\n\n  /**\n   * Delete many item from the local cache\n   */\n  deleteMany(keys: string[], options: CacheEntryOptions) {\n    this.#logger.debug({ keys, options, opId: options.id }, 'deleting items')\n    this.#driver.deleteMany(keys)\n  }\n\n  /**\n   * Make an item logically expire in the local cache\n   */\n  logicallyExpire(key: string, options?: CacheEntryOptions) {\n    this.#logger.debug({ key, opId: options?.id }, 'logically expiring item')\n\n    const value = this.#driver.get(key)\n    if (value === undefined) return\n\n    const newEntry = CacheEntry.fromDriver(key, value, this.#serializer).expire().serialize()\n    return this.#driver.set(key, newEntry as any, this.#driver.getRemainingTtl(key))\n  }\n\n  /**\n   * Create a new namespace for the local cache\n   */\n  namespace(namespace: string) {\n    return this.#driver.namespace(namespace) as L1CacheDriver\n  }\n\n  /**\n   * Clear the local cache\n   */\n  clear() {\n    return this.#driver.clear()\n  }\n\n  /**\n   * Disconnect from the local cache\n   */\n  disconnect() {\n    return this.#driver.disconnect()\n  }\n}\n","import { is } from '@julr/utils/is'\n\nimport { errors } from '../../errors.js'\nimport type { Logger } from '../../logger.js'\nimport type { L2CacheDriver } from '../../types/main.js'\nimport { CacheEntry } from '../cache_entry/cache_entry.js'\nimport { CircuitBreaker } from '../../circuit_breaker/index.js'\nimport type { BentoCacheOptions } from '../../bento_cache_options.js'\nimport type { CacheEntryOptions } from '../cache_entry/cache_entry_options.js'\n\n/**\n * RemoteCache is a wrapper around a L2 Cache Driver that provides\n * some handy methods for interacting with a remote cache ( redis, database, etc )\n */\nexport class RemoteCache {\n  #driver: L2CacheDriver\n  #logger: Logger\n  #hasL1Backup: boolean\n  #circuitBreaker?: CircuitBreaker\n  #options: BentoCacheOptions\n\n  constructor(\n    driver: L2CacheDriver,\n    logger: Logger,\n    hasL1Backup: boolean,\n    options: BentoCacheOptions,\n  ) {\n    this.#driver = driver\n    this.#options = options\n    this.#hasL1Backup = hasL1Backup\n    this.#circuitBreaker = options.l2CircuitBreakerDuration\n      ? new CircuitBreaker({ breakDuration: options.l2CircuitBreakerDuration })\n      : undefined\n\n    this.#logger = logger.child({ layer: 'l2' })\n  }\n\n  /**\n   * Try to execute a cache operation and fallback to a default value\n   * if the operation fails\n   */\n  async #tryCacheOperation<T, K>(\n    operation: string,\n    options: CacheEntryOptions,\n    fallbackValue: K,\n    fn: () => T,\n  ): Promise<T | K> {\n    if (this.#circuitBreaker?.isOpen()) {\n      this.#logger.error({ opId: options.id }, `circuit breaker is open. ignoring operation`)\n      return fallbackValue\n    }\n\n    try {\n      return await fn()\n    } catch (err) {\n      this.#logger.error({ err, opId: options.id }, `(${operation}) failed on remote cache`)\n\n      this.#circuitBreaker?.open()\n\n      /**\n       * SuppressL2Errors is enabled automatically if undefined and we have a L1 backup\n       * Otherwise, we need to check what the user set\n       */\n      if (\n        (is.undefined(options.suppressL2Errors) && this.#hasL1Backup) ||\n        options.suppressL2Errors\n      ) {\n        return fallbackValue\n      }\n\n      throw new errors.E_L2_CACHE_ERROR(err)\n    }\n  }\n\n  /**\n   * Get an item from the remote cache\n   */\n  async get(key: string, options: CacheEntryOptions) {\n    return await this.#tryCacheOperation('get', options, undefined, async () => {\n      const value = await this.#driver.get(key)\n      if (value === undefined) return\n\n      const entry = CacheEntry.fromDriver(key, value, this.#options.serializer)\n      const isGraced = entry.isLogicallyExpired()\n      if (isGraced) {\n        this.#logger.debug({ key, opId: options.id }, 'cache hit (graced)')\n      } else {\n        this.#logger.debug({ key, opId: options.id }, 'cache hit')\n      }\n\n      return { entry, isGraced }\n    })\n  }\n\n  /**\n   * Set a new item in the remote cache\n   */\n  async set(key: string, value: string, options: CacheEntryOptions) {\n    return await this.#tryCacheOperation('set', options, false, async () => {\n      this.#logger.debug({ key, opId: options.id }, 'saving item')\n      await this.#driver.set(key, value, options.getPhysicalTtl())\n      return true\n    })\n  }\n\n  /**\n   * Delete an item from the remote cache\n   */\n  async delete(key: string, options: CacheEntryOptions) {\n    return await this.#tryCacheOperation('delete', options, false, async () => {\n      this.#logger.debug({ key, opId: options.id }, 'deleting item')\n      return await this.#driver.delete(key)\n    })\n  }\n\n  /**\n   * Delete multiple items from the remote cache\n   */\n  async deleteMany(keys: string[], options: CacheEntryOptions) {\n    return await this.#tryCacheOperation('deleteMany', options, false, async () => {\n      this.#logger.debug({ keys, opId: options.id }, 'deleting items')\n      return await this.#driver.deleteMany(keys)\n    })\n  }\n\n  /**\n   * Make an item logically expire in the remote cache\n   */\n  async logicallyExpire(key: string, options: CacheEntryOptions) {\n    return await this.#tryCacheOperation('logicallyExpire', options, false, async () => {\n      this.#logger.debug({ key, opId: options.id }, 'logically expiring item')\n\n      const value = await this.#driver.get(key)\n      if (value === undefined) return\n\n      const entry = CacheEntry.fromDriver(key, value, this.#options.serializer).expire().serialize()\n      return await this.#driver.set(key, entry as any, options.getPhysicalTtl())\n    })\n  }\n\n  /**\n   * Create a new namespace for the remote cache\n   */\n  namespace(namespace: string) {\n    return this.#driver.namespace(namespace) as L2CacheDriver\n  }\n\n  /**\n   * Clear the remote cache\n   */\n  async clear(options: CacheEntryOptions) {\n    return await this.#tryCacheOperation('clear', options, false, async () => {\n      return await this.#driver.clear()\n    })\n  }\n\n  /**\n   * Disconnect from the remote cache\n   */\n  disconnect() {\n    return this.#driver.disconnect()\n  }\n}\n","import { InvalidArgumentsException } from '@poppinss/exception'\n\nconst CircuitBreakerState = { Closed: 0, Open: 1 }\n\ninterface CircuitBreakerOptions {\n  /**\n   * In milliseconds, how long the circuit breaker should stay open\n   */\n  breakDuration: number | undefined\n}\n\n/**\n * Super simple circuit breaker implementation\n */\nexport class CircuitBreaker {\n  #state = CircuitBreakerState.Closed\n  #willCloseAt: number | null = null\n  #breakDuration: number\n\n  constructor(options: CircuitBreakerOptions) {\n    this.#breakDuration = options.breakDuration ?? 0\n    if (this.#breakDuration < 0) {\n      throw new InvalidArgumentsException('breakDuration must be a positive number')\n    }\n\n    this.#state = CircuitBreakerState.Closed\n  }\n\n  /**\n   * Check if the circuit breaker should change state\n   */\n  #checkState() {\n    if (this.#willCloseAt && this.#willCloseAt < Date.now()) this.close()\n  }\n\n  /**\n   * Check if the circuit breaker is open\n   */\n  isOpen() {\n    this.#checkState()\n    return this.#state === CircuitBreakerState.Open\n  }\n\n  /**\n   * Check if the circuit breaker is closed\n   */\n  isClosed() {\n    this.#checkState()\n    return this.#state === CircuitBreakerState.Closed\n  }\n\n  /**\n   * Open the circuit breaker\n   */\n  open() {\n    if (this.#state === CircuitBreakerState.Open) return\n\n    this.#state = CircuitBreakerState.Open\n    this.#willCloseAt = Date.now() + this.#breakDuration\n  }\n\n  /**\n   * Close the circuit breaker\n   */\n  close() {\n    this.#state = CircuitBreakerState.Closed\n    this.#willCloseAt = null\n  }\n}\n","import EventEmitter from 'node:events'\nimport { ms } from '@julr/utils/string/ms'\nimport { noopLogger } from '@julr/utils/logger'\n\nimport { Logger } from './logger.js'\nimport { resolveTtl } from './helpers.js'\nimport type { FactoryError } from './errors.js'\nimport { JsonSerializer } from './serializers/json.js'\nimport type { CacheSerializer, Duration, Emitter, RawBentoCacheOptions } from './types/main.js'\n\nconst defaultSerializer = new JsonSerializer()\n\n/**\n * The default options to use throughout the library\n *\n * Some of them can be override on a per-cache basis\n * or on a per-operation basis\n */\nexport class BentoCacheOptions {\n  #options: RawBentoCacheOptions\n\n  /**\n   * The default TTL for all caches\n   *\n   * @default 30m\n   */\n  ttl: Duration = ms.parse('30m')\n\n  /**\n   * Default prefix for all caches\n   */\n  prefix: string = 'bentocache'\n\n  /**\n   * The grace period options\n   */\n  grace: Duration | false = false\n  graceBackoff: Duration = ms.parse('10s')\n\n  /**\n   * Whether to suppress L2 cache errors\n   */\n  suppressL2Errors?: boolean\n\n  /**\n   * The soft and hard timeouts for the factories\n   */\n  timeout: Duration = 0\n  hardTimeout?: Duration = null\n\n  /**\n   * The logger used throughout the library\n   */\n  logger: Logger\n\n  /**\n   * The emitter used throughout the library\n   */\n  emitter: Emitter = new EventEmitter()\n\n  /**\n   * Serializer to use for the cache\n   */\n  serializer: CacheSerializer\n\n  /**\n   * Max time to wait for the lock to be acquired\n   */\n  lockTimeout?: Duration = null\n\n  /**\n   * Duration for the circuit breaker to stay open\n   * if l2 cache fails\n   */\n  l2CircuitBreakerDuration: number | undefined\n\n  /**\n   * If the L1 cache should be serialized\n   */\n  serializeL1: boolean = true\n  onFactoryError?: (error: FactoryError) => void\n\n  constructor(options: RawBentoCacheOptions) {\n    this.#options = { ...this, ...options }\n\n    this.prefix = this.#options.prefix!\n    this.ttl = this.#options.ttl!\n    this.timeout = this.#options.timeout ?? 0\n    this.hardTimeout = this.#options.hardTimeout\n    this.suppressL2Errors = this.#options.suppressL2Errors\n    this.lockTimeout = this.#options.lockTimeout\n    this.grace = this.#options.grace!\n    this.graceBackoff = this.#options.graceBackoff!\n\n    this.emitter = this.#options.emitter!\n    this.serializer = this.#options.serializer ?? defaultSerializer\n    this.l2CircuitBreakerDuration = resolveTtl(this.#options.l2CircuitBreakerDuration, null)\n\n    this.logger = new Logger(this.#options.logger ?? noopLogger())\n    this.onFactoryError = this.#options.onFactoryError\n  }\n\n  serializeL1Cache(shouldSerialize: boolean = true) {\n    this.serializeL1 = shouldSerialize\n    return this\n  }\n\n  cloneWith(options: RawBentoCacheOptions) {\n    const newOptions = { ...this.#options, ...options }\n    return new BentoCacheOptions(newOptions)\n  }\n}\n","import type { Logger as InternalLogger, LogObject } from '@julr/utils/logger'\n\nimport type { CacheEntryOptions } from './cache/cache_entry/cache_entry_options.js'\n\nexport class Logger {\n  internalLogger: InternalLogger\n\n  constructor(internalLogger: InternalLogger) {\n    this.internalLogger = internalLogger\n  }\n\n  child(obj: LogObject) {\n    return new Logger(this.internalLogger.child(obj))\n  }\n\n  trace(msg: any, obj?: any) {\n    this.internalLogger.trace(msg, obj)\n  }\n\n  debug(msg: any, obj?: any) {\n    this.internalLogger.debug(msg, obj)\n  }\n\n  warn(msg: any, obj?: any) {\n    this.internalLogger.warn(msg, obj)\n  }\n\n  error(msg: any, obj?: any) {\n    this.internalLogger.error(msg, obj)\n  }\n\n  fatal(msg: any, obj?: any) {\n    this.internalLogger.fatal(msg, obj)\n  }\n\n  info(msg: any, obj?: any) {\n    this.internalLogger.info(msg, obj)\n  }\n\n  logMethod(options: {\n    cacheName: string\n    options: CacheEntryOptions\n    key?: string | string[]\n    tags?: string[]\n    method: string\n  }) {\n    this.internalLogger.debug(\n      {\n        cacheName: options.cacheName,\n        opId: options.options.id,\n        key: options.key,\n        tags: options.tags,\n      },\n      `'${options.method}' method called`,\n    )\n  }\n\n  logL1Hit(options: {\n    cacheName: string\n    key: string\n    options: CacheEntryOptions\n    graced?: boolean\n  }) {\n    this.internalLogger.debug(\n      {\n        cacheName: options.cacheName,\n        opId: options.options.id,\n        key: options.key,\n        graced: options.graced,\n      },\n      'memory hit',\n    )\n  }\n\n  logL2Hit(options: {\n    cacheName: string\n    key: string\n    options: CacheEntryOptions\n    graced?: boolean\n  }) {\n    this.internalLogger.debug(\n      {\n        cacheName: options.cacheName,\n        opId: options.options.id,\n        key: options.key,\n        graced: options.graced,\n      },\n      'remote hit',\n    )\n  }\n}\n","import type { CacheSerializer } from '../types/main.js'\n\n/**\n * Simple class to serialize and deserialize values using JSON\n */\nexport class JsonSerializer implements CacheSerializer {\n  serialize(value: unknown) {\n    return JSON.stringify(value)\n  }\n\n  deserialize(value: string) {\n    return JSON.parse(value)\n  }\n}\n","import { Cache } from './cache/cache.js'\nimport type { BentoStore } from './bento_store.js'\nimport { CacheStack } from './cache/cache_stack.js'\nimport type { CacheProvider } from './types/provider.js'\nimport { BentoCacheOptions } from './bento_cache_options.js'\nimport type {\n  CacheEvents,\n  RawBentoCacheOptions,\n  BentoCachePlugin,\n  ClearOptions,\n  GetOrSetForeverOptions,\n  GetOrSetOptions,\n  GetOptions,\n  SetOptions,\n  HasOptions,\n  DeleteOptions,\n  DeleteManyOptions,\n  ExpireOptions,\n  DeleteByTagOptions,\n} from './types/main.js'\n\nexport class BentoCache<KnownCaches extends Record<string, BentoStore>> implements CacheProvider {\n  /**\n   * Name of the default cache\n   */\n  #defaultStoreName: keyof KnownCaches\n\n  /**\n   * List of registered caches\n   */\n  #stores: KnownCaches\n\n  /**\n   * Cache of already instantiated drivers\n   */\n  #driversCache: Map<keyof KnownCaches, CacheProvider> = new Map()\n\n  /**\n   * Bento Cache options instance\n   */\n  #options: BentoCacheOptions\n\n  constructor(\n    config: RawBentoCacheOptions & {\n      default: keyof KnownCaches\n      stores: KnownCaches\n      plugins?: BentoCachePlugin[]\n    },\n  ) {\n    this.#stores = config.stores\n    this.#defaultStoreName = config.default\n\n    this.#options = new BentoCacheOptions(config)\n    this.#options.logger.trace('bentocache initialized')\n\n    /**\n     * Register plugins\n     */\n    if (config.plugins) config.plugins.forEach((plugin) => plugin.register(this))\n  }\n\n  #createProvider(cacheName: string, store: BentoStore): CacheProvider {\n    const entry = store.entry\n    const driverItemOptions = this.#options\n      .cloneWith(entry.options)\n      .serializeL1Cache(entry.l1?.options.serialize ?? true)\n\n    const cacheStack = new CacheStack(cacheName, driverItemOptions, {\n      l1Driver: entry.l1?.factory({ prefix: driverItemOptions.prefix, ...entry.l1.options }),\n      l2Driver: entry.l2?.factory({ prefix: driverItemOptions.prefix, ...entry.l2.options }),\n      busDriver: entry.bus?.factory(entry.bus?.options),\n      busOptions: entry.bus?.options,\n    })\n\n    return new Cache(cacheName, cacheStack)\n  }\n\n  get defaultStoreName() {\n    return this.#defaultStoreName as string\n  }\n\n  /**\n   * Use a registered cache driver\n   */\n  use<CacheName extends keyof KnownCaches>(cache?: CacheName) {\n    const cacheToUse: keyof KnownCaches | undefined = cache || this.#defaultStoreName\n    if (!cacheToUse) throw new Error('No cache driver selected')\n\n    /**\n     * Check if the cache driver was already instantiated\n     */\n    if (this.#driversCache.has(cacheToUse)) {\n      return this.#driversCache.get(cacheToUse)!\n    }\n\n    /**\n     * Otherwise create a new instance and cache it\n     */\n    const provider = this.#createProvider(cacheToUse as string, this.#stores[cacheToUse])\n    this.#driversCache.set(cacheToUse, provider)\n\n    return provider\n  }\n\n  /**\n   * Subscribe to a given cache event\n   */\n  on<Event extends keyof CacheEvents>(event: Event, callback: (arg: CacheEvents[Event]) => void) {\n    this.#options.emitter.on(event, callback)\n    return this\n  }\n\n  /**\n   * Subscribe to a given cache event only once\n   */\n  once<Event extends keyof CacheEvents>(event: Event, callback: (arg: CacheEvents[Event]) => void) {\n    this.#options.emitter.once(event, callback)\n    return this\n  }\n\n  /**\n   * Unsubscribe the callback from the given event\n   */\n  off<Event extends keyof CacheEvents>(event: Event, callback: (arg: CacheEvents[Event]) => void) {\n    this.#options.emitter.off(event, callback)\n    return this\n  }\n\n  /**\n   * Returns a new instance of the driver namespaced\n   */\n  namespace(namespace: string) {\n    return this.use().namespace(namespace)\n  }\n\n  /**\n   * Get a value from the cache\n   */\n  async get<T = any>(options: GetOptions<T>): Promise<T> {\n    return this.use().get<T>(options)\n  }\n\n  /**\n   * Put a value in the cache\n   * Returns true if the value was set, false otherwise\n   */\n  async set(options: SetOptions) {\n    return this.use().set(options)\n  }\n\n  /**\n   * Put a value in the cache forever\n   * Returns true if the value was set, false otherwise\n   */\n  async setForever(options: SetOptions) {\n    return this.use().setForever(options)\n  }\n\n  /**\n   * Retrieve an item from the cache if it exists, otherwise store the value\n   * provided by the factory and return it\n   */\n  async getOrSet<T>(options: GetOrSetOptions<T>): Promise<T> {\n    return this.use().getOrSet(options)\n  }\n\n  /**\n   * Retrieve an item from the cache if it exists, otherwise store the value\n   * provided by the factory forever and return it\n   */\n  getOrSetForever<T>(options: GetOrSetForeverOptions<T>): Promise<T> {\n    return this.use().getOrSetForever(options)\n  }\n\n  /**\n   * Check if a key exists in the cache\n   */\n  async has(options: HasOptions) {\n    return this.use().has(options)\n  }\n\n  /**\n   * Check if key is missing in the cache\n   */\n  async missing(options: HasOptions) {\n    return this.use().missing(options)\n  }\n\n  /**\n   * Get the value of a key and delete it\n   *\n   * Returns the value if the key exists, undefined otherwise\n   */\n  async pull<T = any>(key: string) {\n    return this.use().pull<T>(key)\n  }\n\n  /**\n   * Delete a key from the cache\n   * Returns true if the key was deleted, false otherwise\n   */\n  async delete(keyOrOptions: DeleteOptions) {\n    return this.use().delete(keyOrOptions)\n  }\n\n  /**\n   * Delete multiple keys from the cache\n   */\n  async deleteMany(options: DeleteManyOptions): Promise<boolean> {\n    return this.use().deleteMany(options)\n  }\n\n  /**\n   * Delete all keys with a specific tag\n   */\n  async deleteByTag(options: DeleteByTagOptions): Promise<boolean> {\n    return this.use().deleteByTag(options)\n  }\n\n  /**\n   * Expire a key from the cache.\n   * Entry will not be fully deleted but expired and\n   * retained for the grace period if enabled.\n   */\n  async expire(options: ExpireOptions) {\n    return this.use().expire(options)\n  }\n\n  /**\n   * Remove all items from the cache\n   */\n  async clear(options?: ClearOptions) {\n    return this.use().clear(options)\n  }\n\n  /**\n   * Remove all items from all caches\n   */\n  async clearAll(options?: ClearOptions) {\n    await Promise.all(Object.keys(this.#stores).map((cache) => this.use(cache).clear(options)))\n  }\n\n  /**\n   * Closes the connection to the cache\n   */\n  async disconnect() {\n    return this.use().disconnect()\n  }\n\n  /**\n   * Disconnect all cache connections created by the manager\n   */\n  async disconnectAll(): Promise<void> {\n    await Promise.all(Object.keys(this.#stores).map((cache) => this.use(cache).disconnect()))\n  }\n}\n","import type {\n  CreateBusDriverResult,\n  CreateDriverResult,\n  L1CacheDriver,\n  L2CacheDriver,\n  RawCommonOptions,\n} from './types/main.js'\n\n/**\n * Create a new store\n */\nexport function bentostore(options?: RawCommonOptions & { prefix?: string }) {\n  return new BentoStore(options)\n}\n\nexport class BentoStore {\n  #baseOptions: RawCommonOptions & { prefix?: string } = {}\n  #l1?: CreateDriverResult<L1CacheDriver>\n  #l2?: CreateDriverResult<L2CacheDriver>\n  #bus?: CreateBusDriverResult\n\n  constructor(baseOptions: RawCommonOptions & { prefix?: string } = {}) {\n    this.#baseOptions = baseOptions\n  }\n\n  /**\n   * Add a L1 layer to your store. This is usually a memory driver\n   * for fast access purposes.\n   */\n  useL1Layer(driver: CreateDriverResult<L1CacheDriver>) {\n    this.#l1 = driver\n    return this\n  }\n\n  /**\n   * Add a L2 layer to your store. This is usually something\n   * distributed like Redis, DynamoDB, Sql database, etc.\n   */\n  useL2Layer(driver: CreateDriverResult<L2CacheDriver>) {\n    this.#l2 = driver\n    return this\n  }\n\n  /**\n   * Add a bus to your store. It will be used to synchronize L1 layers between\n   * different instances of your application.\n   */\n  useBus(bus: CreateBusDriverResult) {\n    this.#bus = bus\n    return this\n  }\n\n  get entry() {\n    return {\n      options: this.#baseOptions,\n      l1: this.#l1,\n      l2: this.#l2,\n      bus: this.#bus,\n    }\n  }\n}\n"],"mappings":"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","names":["is","result","is","is","is","newOptions","is","is","is","is"]}