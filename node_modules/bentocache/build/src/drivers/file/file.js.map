{"version":3,"sources":["../../../../src/drivers/file/file.ts"],"sourcesContent":["import { dirname, join } from 'node:path'\nimport { Worker } from 'node:worker_threads'\nimport { access, mkdir, readFile, writeFile, rm } from 'node:fs/promises'\n\nimport { resolveTtl } from '../../helpers.js'\nimport { BaseDriver } from '../base_driver.js'\nimport type { CacheDriver, CreateDriverResult, FileConfig } from '../../types/main.js'\n\n/**\n * Create a new file driver\n */\nexport function fileDriver(options: FileConfig): CreateDriverResult<FileDriver> {\n  return { options, factory: (config: FileConfig) => new FileDriver(config) }\n}\n\n/**\n * Caching driver for the filesystem\n *\n * - Each key is stored as a file in the filesystem.\n * - Each namespace is a folder created in the parent namespace\n * - Files are stored in the following format: [stringifiedValue, expireTimestamp]\n * - If the expireTimestamp is -1, the value should never expire\n */\nexport class FileDriver extends BaseDriver implements CacheDriver {\n  type = 'l2' as const\n\n  /**\n   * Root directory for storing the cache files\n   */\n  #directory: string\n\n  /**\n   * Worker thread that will clean up the expired files\n   */\n  #cleanerWorker?: Worker\n\n  declare config: FileConfig\n\n  constructor(config: FileConfig, isNamespace: boolean = false) {\n    super(config)\n\n    this.#directory = this.#sanitizePath(join(config.directory, config.prefix || ''))\n\n    /**\n     * If this is a namespaced class, then we should not start the cleaner\n     * worker multiple times. Only the parent class will take care of it.\n     */\n    if (isNamespace) return\n    if (config.pruneInterval === false) return\n\n    this.#cleanerWorker = new Worker(new URL('./cleaner_worker.js', import.meta.url), {\n      workerData: { directory: this.#directory, pruneInterval: resolveTtl(config.pruneInterval) },\n    })\n  }\n\n  /**\n   * Since keys and namespace uses `:` as a separator, we need to\n   * purge them from the given path. We replace them with `/` to\n   * create a nested directory structure.\n   */\n  #sanitizePath(path?: string) {\n    if (!path) return ''\n    return path.replaceAll(':', '/')\n  }\n\n  /**\n   * Converts the given key to a file path\n   */\n  #keyToPath(key: string) {\n    const keyWithoutPrefix = key.replace(this.prefix, '')\n\n    /**\n     * Check if the key contains a relative path\n     */\n    const re = /(\\.\\/|\\.\\.\\/)/g\n    if (re.test(key)) {\n      throw new Error(`Invalid key: ${keyWithoutPrefix}. Should not contain relative paths.`)\n    }\n\n    return join(this.#directory, this.#sanitizePath(keyWithoutPrefix))\n  }\n\n  /**\n   * Check if a file exists at a given path or not\n   */\n  async #pathExists(path: string) {\n    try {\n      await access(path)\n      return true\n    } catch {\n      return false\n    }\n  }\n\n  /**\n   * Output a file to the disk and create the directory recursively if\n   * it's missing\n   */\n  async #outputFile(filename: string, content: string) {\n    const directory = dirname(filename)\n    const pathExists = await this.#pathExists(directory)\n    if (!pathExists) {\n      await mkdir(directory, { recursive: true })\n    }\n\n    await writeFile(filename, content)\n  }\n\n  /**\n   * Returns a new instance of the driver namespaced\n   */\n  namespace(namespace: string) {\n    return new FileDriver({ ...this.config, prefix: this.createNamespacePrefix(namespace) }, true)\n  }\n\n  /**\n   * Get a value from the cache\n   */\n  async get(key: string) {\n    key = this.getItemKey(key)\n\n    const path = this.#keyToPath(key)\n    const pathExists = await this.#pathExists(path)\n    if (!pathExists) {\n      return undefined\n    }\n\n    const content = await readFile(path, { encoding: 'utf-8' })\n    const [value, expire] = JSON.parse(content)\n\n    if (expire !== -1 && expire < Date.now()) {\n      await this.delete(key)\n      return undefined\n    }\n\n    return value as string\n  }\n\n  /**\n   * Get the value of a key and delete it\n   *\n   * Returns the value if the key exists, undefined otherwise\n   */\n  async pull(key: string) {\n    const value = await this.get(key)\n    if (!value) return undefined\n\n    await this.delete(key)\n    return value\n  }\n\n  /**\n   * Put a value in the cache\n   * Returns true if the value was set, false otherwise\n   */\n  async set(key: string, value: string, ttl?: number) {\n    key = this.getItemKey(key)\n    await this.#outputFile(\n      this.#keyToPath(key),\n      JSON.stringify([value, ttl ? Date.now() + ttl : -1]),\n    )\n\n    return true\n  }\n\n  /**\n   * Remove all items from the cache\n   */\n  async clear() {\n    const cacheExists = await this.#pathExists(this.#directory)\n    if (!cacheExists) return\n\n    /**\n     * By removing the directory and sub-directories, we are also\n     * removing the namespaces inside it\n     */\n    await rm(this.#directory, { recursive: true })\n  }\n\n  /**\n   * Delete a key from the cache\n   * Returns true if the key was deleted, false otherwise\n   */\n  async delete(key: string) {\n    key = this.getItemKey(key)\n\n    const path = this.#keyToPath(key)\n    const pathExists = await this.#pathExists(path)\n    if (!pathExists) {\n      return false\n    }\n\n    await rm(path)\n    return true\n  }\n\n  /**\n   * Delete multiple keys from the cache\n   */\n  async deleteMany(keys: string[]) {\n    if (keys.length === 0) return true\n    await Promise.all(keys.map((key) => this.delete(key)))\n    return true\n  }\n\n  async disconnect() {\n    await this.#cleanerWorker?.terminate()\n  }\n}\n"],"mappings":"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","names":[]}