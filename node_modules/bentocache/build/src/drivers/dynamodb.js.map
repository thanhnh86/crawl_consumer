{"version":3,"sources":["../../../src/drivers/dynamodb.ts"],"sourcesContent":["import { chunkify } from '@julr/utils/array/chunkify'\nimport {\n  DynamoDBClient,\n  GetItemCommand,\n  PutItemCommand,\n  DeleteItemCommand,\n  BatchWriteItemCommand,\n  ScanCommand,\n  type AttributeValue,\n  ConditionalCheckFailedException,\n} from '@aws-sdk/client-dynamodb'\n\nimport { BaseDriver } from './base_driver.js'\nimport type { CacheDriver, CreateDriverResult, DynamoDBConfig } from '../types/main.js'\n\n/**\n * Create a new DynamoDB driver\n */\nexport function dynamoDbDriver(options: DynamoDBConfig): CreateDriverResult<DynamoDbDriver> {\n  return {\n    options,\n    factory: (config: DynamoDBConfig) => new DynamoDbDriver(config),\n  }\n}\n\n/**\n * Caching driver for DynamoDB\n */\nexport class DynamoDbDriver extends BaseDriver implements CacheDriver {\n  type = 'l2' as const\n\n  /**\n   * DynamoDB client\n   */\n  #client: DynamoDBClient\n\n  /**\n   * Configuration\n   */\n  declare config: DynamoDBConfig\n\n  /**\n   * Name of the table to use\n   * Defaults to `cache`\n   */\n  #tableName: string\n\n  constructor(config: DynamoDBConfig & { client?: DynamoDBClient }) {\n    super(config)\n\n    this.#tableName = this.config.table.name ?? 'cache'\n\n    if (config.client) {\n      this.#client = config.client\n      return\n    }\n\n    this.#client = new DynamoDBClient({\n      region: config.region,\n      credentials: config.credentials,\n      endpoint: config.endpoint,\n    })\n  }\n\n  /**\n   * Try to delete an item from the cache.\n   * If the item doesn't exist, a `ConditionalCheckFailedException` is thrown.\n   */\n  async #deleteItem(key: string) {\n    await this.#client.send(\n      new DeleteItemCommand({\n        TableName: this.#tableName,\n        Key: { key: { S: this.getItemKey(key) } },\n        ConditionExpression: 'attribute_exists(#key)',\n        ExpressionAttributeNames: { '#key': 'key' },\n      }),\n    )\n  }\n\n  /**\n   * Scan the table for items with our prefix\n   * Returns a paginated list of items\n   */\n  async #getStoredItems(exclusiveStartKey?: Record<string, AttributeValue>) {\n    return await this.#client.send(\n      new ScanCommand({\n        TableName: this.#tableName,\n        ProjectionExpression: '#key',\n        FilterExpression: 'begins_with(#key, :prefix)',\n        ExpressionAttributeNames: { '#key': 'key' },\n        ExpressionAttributeValues: { ':prefix': { S: `${this.prefix}:` } },\n        ExclusiveStartKey: exclusiveStartKey,\n      }),\n    )\n  }\n\n  /**\n   * Delete multiple items from our table\n   */\n  async #batchDeleteItems(items: Record<string, AttributeValue>[]) {\n    const requests = items.map((item) => ({ DeleteRequest: { Key: item } }))\n    const command = new BatchWriteItemCommand({ RequestItems: { [this.#tableName]: requests } })\n    await this.#client.send(command)\n  }\n\n  /**\n   * Check if the given item TTL is expired.\n   *\n   * We have to do this manually for local execution against\n   * the dynamodb-local docker image since it doesn't support\n   * TTLs.\n   */\n  #isItemExpired(item: Record<string, AttributeValue>) {\n    if (!item.ttl) return false\n\n    const now = Math.floor(Date.now() / 1000)\n    return Number(item.ttl.N) < now\n  }\n\n  /**\n   * Convert a TTL duration in miliseconds to\n   * a UNIX timestamp in seconds since DynamoDB\n   * accepts this format.\n   */\n  #computeTtl(ttl: number) {\n    return Math.floor((Date.now() + ttl) / 1000).toString()\n  }\n\n  /**\n   * Generate the payload for a WriteRequest\n   *\n   * We append the TTL attribute only if a TTL is defined.\n   * If no TTL is defined, the item will never expire.\n   */\n  #createItemPayload(key: string, value: string, ttl?: number): Record<string, AttributeValue> {\n    return {\n      key: { S: this.getItemKey(key) },\n      value: { S: value },\n      ...(ttl ? { ttl: { N: this.#computeTtl(ttl) } } : {}),\n    }\n  }\n\n  /**\n   * Returns a new instance of the driver with the given namespace.\n   */\n  namespace(namespace: string) {\n    return new DynamoDbDriver({\n      ...this.config,\n      client: this.#client,\n      prefix: this.createNamespacePrefix(namespace),\n    })\n  }\n\n  /**\n   * Get a value from the cache\n   */\n  async get(key: string) {\n    const command = new GetItemCommand({\n      Key: { key: { S: this.getItemKey(key) } },\n      TableName: this.#tableName,\n    })\n\n    const data = await this.#client.send(command)\n\n    if (!data.Item || this.#isItemExpired(data.Item)) {\n      return undefined\n    }\n\n    return data.Item.value.S ?? data.Item.value.N\n  }\n\n  /**\n   * Get the value of a key and delete it\n   *\n   * Returns the value if the key exists, undefined otherwise\n   */\n  async pull(key: string) {\n    const value = await this.get(key)\n    if (value === undefined) {\n      return undefined\n    }\n\n    await this.delete(key)\n    return value\n  }\n\n  /**\n   * Put a value in the cache\n   * Returns true if the value was set, false otherwise\n   */\n  async set(key: string, value: string, ttl?: number) {\n    const command = new PutItemCommand({\n      TableName: this.#tableName,\n      Item: this.#createItemPayload(key, value, ttl),\n    })\n\n    await this.#client.send(command)\n\n    return true\n  }\n\n  /**\n   * Remove all items from the cache\n   */\n  async clear() {\n    let exclusiveStartKey: Record<string, AttributeValue> | undefined\n\n    do {\n      /**\n       * Scan the table for items that have the store prefix. This\n       * call is paginated, so we need to repeat until there are\n       * no more items to delete.\n       */\n      const result = await this.#getStoredItems(exclusiveStartKey)\n\n      /**\n       * Make chunks of 25 items since AWS only allows deleting 25 items\n       * at a time\n       */\n      const chunkedItems = chunkify(result.Items ?? [], 25)\n\n      /**\n       * Delete items, one chunk at a time to avoid exceeding the\n       * provisioned throughput for the table.\n       *\n       * A better approach would be to use configured provisioned throughput\n       * and use the `ReturnConsumedCapacity` parameter to check if the\n       * throughput is exceeded. If it is, wait for a bit and try again.\n       */\n      for (const chunk of chunkedItems) {\n        await this.#batchDeleteItems(chunk)\n      }\n\n      /**\n       * Repeat until there are no more items to delete\n       */\n      exclusiveStartKey = result.LastEvaluatedKey\n    } while (exclusiveStartKey)\n  }\n\n  /**\n   * Delete a key from the cache\n   * Returns true if the key was deleted, false otherwise\n   */\n  async delete(key: string) {\n    try {\n      await this.#deleteItem(key)\n      return true\n    } catch (error) {\n      if (error instanceof ConditionalCheckFailedException) {\n        return false\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Delete multiple keys from the cache\n   */\n  async deleteMany(keys: string[]) {\n    if (keys.length === 0) return true\n    await Promise.all(keys.map((key) => this.delete(key)))\n    return true\n  }\n\n  /**\n   * Closes the connection to the cache\n   */\n  async disconnect() {\n    this.#client.destroy()\n  }\n}\n"],"mappings":"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","names":[]}