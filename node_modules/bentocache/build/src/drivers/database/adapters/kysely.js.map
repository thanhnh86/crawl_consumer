{"version":3,"sources":["../../../../../src/drivers/database/adapters/kysely.ts"],"sourcesContent":["import { SqliteAdapter, type Kysely, MysqlAdapter } from 'kysely'\n\nimport { DatabaseDriver } from '../database.js'\nimport type { CreateDriverResult, DatabaseAdapter, KyselyConfig } from '../../../types/main.js'\n\n/**\n * Create a kysely driver\n * You will need to install the underlying database package (mysql2, pg, sqlite3, etc)\n */\nexport function kyselyDriver(options: KyselyConfig): CreateDriverResult<DatabaseDriver> {\n  return {\n    options,\n    factory: (config: KyselyConfig) => {\n      const adapter = new KyselyAdapter(config)\n      return new DatabaseDriver(adapter, config)\n    },\n  }\n}\n\n/**\n * Kysely adapter for the DatabaseDriver\n */\nexport class KyselyAdapter implements DatabaseAdapter {\n  #dialect: 'mysql' | 'pg' | 'sqlite'\n  #tableName!: string\n  #connection: Kysely<any>\n\n  constructor(config: KyselyConfig) {\n    this.#connection = config.connection\n\n    const adapter = this.#connection.getExecutor().adapter\n    if (adapter instanceof SqliteAdapter) {\n      this.#dialect = 'sqlite'\n    } else if (adapter instanceof MysqlAdapter) {\n      this.#dialect = 'mysql'\n    } else {\n      this.#dialect = 'pg'\n    }\n  }\n\n  setTableName(tableName: string): void {\n    this.#tableName = tableName\n  }\n\n  async get(key: string): Promise<{ value: any; expiresAt: number | null } | undefined> {\n    const result = await this.#connection\n      .selectFrom(this.#tableName)\n      .select(['value', 'expires_at'])\n      .where('key', '=', key)\n      .executeTakeFirst()\n\n    if (!result) return\n\n    return { value: result.value, expiresAt: result.expires_at }\n  }\n\n  async delete(key: string): Promise<boolean> {\n    const result = await this.#connection\n      .deleteFrom(this.#tableName)\n      .where('key', '=', key)\n      .executeTakeFirst()\n\n    return result.numDeletedRows > 0\n  }\n\n  async deleteMany(keys: string[]): Promise<number> {\n    const result = await this.#connection\n      .deleteFrom(this.#tableName)\n      .where('key', 'in', keys)\n      .executeTakeFirst()\n\n    return +result.numDeletedRows.toString()\n  }\n\n  async disconnect(): Promise<void> {\n    await this.#connection.destroy()\n  }\n\n  async createTableIfNotExists(): Promise<void> {\n    await this.#connection.schema\n      .createTable(this.#tableName)\n      .addColumn('key', 'varchar(255)', (col) => col.primaryKey().notNull())\n      .addColumn('value', 'text')\n      .addColumn('expires_at', 'bigint')\n      .ifNotExists()\n      .execute()\n  }\n\n  async pruneExpiredEntries(): Promise<void> {\n    await this.#connection\n      .deleteFrom(this.#tableName)\n      .where('expires_at', '<', Date.now())\n      .execute()\n  }\n\n  async clear(prefix: string): Promise<void> {\n    await this.#connection.deleteFrom(this.#tableName).where('key', 'like', `${prefix}%`).execute()\n  }\n\n  async set(row: { value: any; key: string; expiresAt: Date | null }): Promise<void> {\n    const expiresAt = this.#dialect === 'sqlite' ? row.expiresAt?.getTime() : row.expiresAt\n\n    await this.#connection\n      .insertInto(this.#tableName)\n      .values({ key: row.key, value: row.value, expires_at: expiresAt ?? null })\n      .$if(this.#dialect === 'mysql', (query) =>\n        query.onDuplicateKeyUpdate({ value: row.value, expires_at: expiresAt }),\n      )\n      .$if(this.#dialect !== 'mysql', (query) => {\n        return query.onConflict((conflict) => {\n          return conflict.columns(['key']).doUpdateSet({ value: row.value, expires_at: expiresAt })\n        })\n      })\n      .execute()\n  }\n}\n"],"mappings":";;;;;;;AAAA,SAAS,eAA4B,oBAAoB;AASlD,SAAS,aAAa,SAA2D;AACtF,SAAO;AAAA,IACL;AAAA,IACA,SAAS,CAAC,WAAyB;AACjC,YAAM,UAAU,IAAI,cAAc,MAAM;AACxC,aAAO,IAAI,eAAe,SAAS,MAAM;AAAA,IAC3C;AAAA,EACF;AACF;AAKO,IAAM,gBAAN,MAA+C;AAAA,EACpD;AAAA,EACA;AAAA,EACA;AAAA,EAEA,YAAY,QAAsB;AAChC,SAAK,cAAc,OAAO;AAE1B,UAAM,UAAU,KAAK,YAAY,YAAY,EAAE;AAC/C,QAAI,mBAAmB,eAAe;AACpC,WAAK,WAAW;AAAA,IAClB,WAAW,mBAAmB,cAAc;AAC1C,WAAK,WAAW;AAAA,IAClB,OAAO;AACL,WAAK,WAAW;AAAA,IAClB;AAAA,EACF;AAAA,EAEA,aAAa,WAAyB;AACpC,SAAK,aAAa;AAAA,EACpB;AAAA,EAEA,MAAM,IAAI,KAA4E;AACpF,UAAM,SAAS,MAAM,KAAK,YACvB,WAAW,KAAK,UAAU,EAC1B,OAAO,CAAC,SAAS,YAAY,CAAC,EAC9B,MAAM,OAAO,KAAK,GAAG,EACrB,iBAAiB;AAEpB,QAAI,CAAC,OAAQ;AAEb,WAAO,EAAE,OAAO,OAAO,OAAO,WAAW,OAAO,WAAW;AAAA,EAC7D;AAAA,EAEA,MAAM,OAAO,KAA+B;AAC1C,UAAM,SAAS,MAAM,KAAK,YACvB,WAAW,KAAK,UAAU,EAC1B,MAAM,OAAO,KAAK,GAAG,EACrB,iBAAiB;AAEpB,WAAO,OAAO,iBAAiB;AAAA,EACjC;AAAA,EAEA,MAAM,WAAW,MAAiC;AAChD,UAAM,SAAS,MAAM,KAAK,YACvB,WAAW,KAAK,UAAU,EAC1B,MAAM,OAAO,MAAM,IAAI,EACvB,iBAAiB;AAEpB,WAAO,CAAC,OAAO,eAAe,SAAS;AAAA,EACzC;AAAA,EAEA,MAAM,aAA4B;AAChC,UAAM,KAAK,YAAY,QAAQ;AAAA,EACjC;AAAA,EAEA,MAAM,yBAAwC;AAC5C,UAAM,KAAK,YAAY,OACpB,YAAY,KAAK,UAAU,EAC3B,UAAU,OAAO,gBAAgB,CAAC,QAAQ,IAAI,WAAW,EAAE,QAAQ,CAAC,EACpE,UAAU,SAAS,MAAM,EACzB,UAAU,cAAc,QAAQ,EAChC,YAAY,EACZ,QAAQ;AAAA,EACb;AAAA,EAEA,MAAM,sBAAqC;AACzC,UAAM,KAAK,YACR,WAAW,KAAK,UAAU,EAC1B,MAAM,cAAc,KAAK,KAAK,IAAI,CAAC,EACnC,QAAQ;AAAA,EACb;AAAA,EAEA,MAAM,MAAM,QAA+B;AACzC,UAAM,KAAK,YAAY,WAAW,KAAK,UAAU,EAAE,MAAM,OAAO,QAAQ,GAAG,MAAM,GAAG,EAAE,QAAQ;AAAA,EAChG;AAAA,EAEA,MAAM,IAAI,KAAyE;AACjF,UAAM,YAAY,KAAK,aAAa,WAAW,IAAI,WAAW,QAAQ,IAAI,IAAI;AAE9E,UAAM,KAAK,YACR,WAAW,KAAK,UAAU,EAC1B,OAAO,EAAE,KAAK,IAAI,KAAK,OAAO,IAAI,OAAO,YAAY,aAAa,KAAK,CAAC,EACxE;AAAA,MAAI,KAAK,aAAa;AAAA,MAAS,CAAC,UAC/B,MAAM,qBAAqB,EAAE,OAAO,IAAI,OAAO,YAAY,UAAU,CAAC;AAAA,IACxE,EACC,IAAI,KAAK,aAAa,SAAS,CAAC,UAAU;AACzC,aAAO,MAAM,WAAW,CAAC,aAAa;AACpC,eAAO,SAAS,QAAQ,CAAC,KAAK,CAAC,EAAE,YAAY,EAAE,OAAO,IAAI,OAAO,YAAY,UAAU,CAAC;AAAA,MAC1F,CAAC;AAAA,IACH,CAAC,EACA,QAAQ;AAAA,EACb;AACF;","names":[]}