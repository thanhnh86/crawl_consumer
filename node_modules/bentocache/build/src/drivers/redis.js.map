{"version":3,"sources":["../../../src/drivers/redis.ts","../../../src/bus/encoders/binary_encoder.ts"],"sourcesContent":["import { Redis as IoRedis } from 'ioredis'\nimport type { RedisOptions as IoRedisOptions } from 'ioredis'\nimport { RedisTransport } from '@boringnode/bus/transports/redis'\nimport type { RedisTransportConfig } from '@boringnode/bus/types/main'\n\nimport { BaseDriver } from './base_driver.js'\nimport { BinaryEncoder } from '../bus/encoders/binary_encoder.js'\nimport type {\n  BusOptions,\n  CreateBusDriverResult,\n  CreateDriverResult,\n  L2CacheDriver,\n  RedisConfig,\n} from '../types/main.js'\n\n/**\n * Create a new cache redis driver\n */\nexport function redisDriver(options: RedisConfig): CreateDriverResult<RedisDriver> {\n  return { options, factory: (config: RedisConfig) => new RedisDriver(config) }\n}\n\n/**\n * Create a new bus redis driver. It leverages the Pub/sub capabilities of Redis\n * to sending messages between your different processes.\n */\nexport function redisBusDriver(\n  options: { connection: IoRedisOptions } & BusOptions,\n): CreateBusDriverResult {\n  return {\n    options,\n    factory: () => {\n      return new RedisTransport(\n        { ...options.connection, useMessageBuffer: true } as RedisTransportConfig,\n        new BinaryEncoder(),\n      )\n    },\n  }\n}\n\n/**\n * Caching driver for Redis\n */\nexport class RedisDriver extends BaseDriver implements L2CacheDriver {\n  type = 'l2' as const\n  #connection: IoRedis\n  declare config: RedisConfig\n\n  constructor(config: RedisConfig) {\n    super(config)\n\n    if (config.connection instanceof IoRedis) {\n      this.#connection = config.connection\n      return\n    }\n\n    this.#connection = new IoRedis(config.connection)\n  }\n\n  getConnection() {\n    return this.#connection\n  }\n\n  /**\n   * Returns a new instance of the driver namespaced\n   */\n  namespace(namespace: string) {\n    return new RedisDriver({\n      ...this.config,\n      connection: this.#connection,\n      prefix: this.createNamespacePrefix(namespace),\n    })\n  }\n\n  /**\n   * Get a value from the cache\n   */\n  async get(key: string) {\n    const result = await this.#connection.get(this.getItemKey(key))\n    return result ?? undefined\n  }\n\n  /**\n   * Get the value of a key and delete it\n   *\n   * Returns the value if the key exists, undefined otherwise\n   */\n  async pull(key: string) {\n    const value = await this.#connection.getdel(this.getItemKey(key))\n\n    return value ?? undefined\n  }\n\n  /**\n   * Put a value in the cache\n   * Returns true if the value was set, false otherwise\n   */\n  async set(key: string, value: string, ttl?: number) {\n    key = this.getItemKey(key)\n\n    if (!ttl) {\n      const result = await this.#connection.set(key, value)\n      return result === 'OK'\n    }\n\n    const result = await this.#connection.set(key, value, 'PX', ttl)\n    return result === 'OK'\n  }\n\n  /**\n   * Remove all items from the cache\n   */\n  async clear() {\n    let cursor = '0'\n    const COUNT = 1000\n    const prefix = this.prefix && `${this.prefix}:`\n    const connectionKeyPrefix = this.#connection.options.keyPrefix\n\n    do {\n      const [newCursor, keys] = await this.#connection.scan(\n        cursor,\n        'MATCH',\n        `${connectionKeyPrefix}${prefix}*`,\n        'COUNT',\n        COUNT,\n      )\n\n      if (keys.length)\n        this.#connection.unlink(keys.map((key) => key.slice(connectionKeyPrefix?.length)))\n\n      cursor = newCursor\n    } while (cursor !== '0')\n  }\n\n  /**\n   * Delete a key from the cache\n   * Returns true if the key was deleted, false otherwise\n   */\n  async delete(key: string) {\n    const deletedKeys = await this.#connection.unlink(this.getItemKey(key))\n    return deletedKeys > 0\n  }\n\n  /**\n   * Delete multiple keys from the cache\n   */\n  async deleteMany(keys: string[]) {\n    if (keys.length === 0) return true\n    await this.#connection.unlink(keys.map((key) => this.getItemKey(key)))\n    return true\n  }\n\n  /**\n   * Closes the connection to the cache\n   */\n  async disconnect() {\n    this.#connection.disconnect()\n  }\n}\n","import type { TransportEncoder } from '@boringnode/bus/types/main'\n\nimport { CacheBusMessageType } from '../../types/bus.js'\nimport type { CacheBusMessage } from '../../types/bus.js'\n\n/**\n * A Binary Encoder that encodes and decodes CacheBusMessage\n *\n * The encoding is as follows:\n * - The bus ID is encoded as a UTF8 string and directly appended to the resulting buffer.\n *   Note that the length of the bus ID should be specified in the constructor.\n *\n * - The message type is encoded as a single byte, with 0x01 for 'Set' message, and 0x02 for a 'Delete' message\n *\n * - The keys are encoded as follows:\n *   - A 4-byte big-endian integer representing the length of the key in bytes\n *   - The key itself\n *\n * - These components are concatenated together in the order busId -> type -> keys\n *\n */\nexport class BinaryEncoder implements TransportEncoder {\n  #busIdLength: number\n\n  /**\n   * We assume the bus ID is a string of length 24 by default.\n   * Because this is the default length of a cuid\n   */\n  constructor(busIdLength = 24) {\n    this.#busIdLength = busIdLength\n  }\n\n  protected busMessageTypeToNum(type: CacheBusMessageType): number {\n    if (type === CacheBusMessageType.Set) return 0x01\n    if (type === CacheBusMessageType.Clear) return 0x02\n    if (type === CacheBusMessageType.Delete) return 0x03\n    if (type === CacheBusMessageType.Expire) return 0x04\n\n    throw new Error(`Unknown message type: ${type}`)\n  }\n\n  protected numToBusMessageType(num: number): CacheBusMessageType {\n    if (num === 0x01) return CacheBusMessageType.Set\n    if (num === 0x02) return CacheBusMessageType.Clear\n    if (num === 0x03) return CacheBusMessageType.Delete\n    if (num === 0x04) return CacheBusMessageType.Expire\n\n    throw new Error(`Unknown message type: ${num}`)\n  }\n\n  /**\n   * Encode the given message into a Buffer\n   */\n  encode(message: any): string | Buffer {\n    const payload = message.payload as Omit<CacheBusMessage, 'busId'>\n\n    /**\n     * Compute the total size needed for storing the keys\n     */\n    const totalKeysLength = payload.keys.reduce(\n      (sum, key) => sum + 4 + Buffer.byteLength(key, 'utf8'),\n      0,\n    )\n\n    const namespaceKeyLength = payload.namespace ? Buffer.byteLength(payload.namespace, 'utf8') : 0\n\n    const totalLength = this.#busIdLength + 1 + 4 + namespaceKeyLength + totalKeysLength\n\n    /**\n     * Allocate a single buffer for the entire message\n     */\n    const buffer = Buffer.alloc(totalLength)\n\n    /**\n     * 1. write the bus ID\n     */\n    buffer.write(message.busId, 0, this.#busIdLength, 'utf8')\n\n    /**\n     * 2. write the message type. 0x01 for 'Set' message, and 0x02 for a 'Delete' message\n     */\n    buffer.writeUInt8(this.busMessageTypeToNum(payload.type), this.#busIdLength)\n\n    /**\n     * 3. Write the namespace\n     */\n    let offset = this.#busIdLength + 1\n    /**\n     * Write the length of the namespace key\n     */\n    buffer.writeUInt32BE(namespaceKeyLength, offset)\n    offset += 4\n\n    /**\n     * Write the namespace itself, if not empty\n     */\n    if (payload.namespace) {\n      buffer.write(payload.namespace, offset, namespaceKeyLength, 'utf8')\n      offset += namespaceKeyLength\n    }\n\n    /**\n     * 4. Write the keys\n     */\n    for (const key of payload.keys) {\n      /**\n       * Compute the length of the key in bytes and write it as a 4-byte big-endian integer\n       */\n      const keyLength = Buffer.byteLength(key, 'utf8')\n      buffer.writeUInt32BE(keyLength, offset)\n      offset += 4\n\n      /**\n       * Write the key itself\n       */\n      buffer.write(key, offset, keyLength, 'utf8')\n      offset += keyLength\n    }\n\n    return buffer\n  }\n\n  /**\n   * Decode the given Buffer into a CacheBusMessage\n   */\n  decode(data: string | Buffer): any {\n    let offset = 0\n    const buffer = Buffer.isBuffer(data) ? data : Buffer.from(data, 'binary')\n\n    /**\n     * First #busIdLength bytes are the bus ID\n     */\n    const busId = buffer.toString('utf8', offset, this.#busIdLength)\n    offset += this.#busIdLength\n\n    /**\n     * Then comes the message type as a single byte\n     */\n    const typeValue = buffer.readUInt8(offset++)\n    const type = this.numToBusMessageType(typeValue)\n\n    /**\n     * Then the namespace\n     */\n    const namespaceKeyLength = buffer.readUInt32BE(offset)\n    offset += 4\n\n    const namespace = namespaceKeyLength\n      ? buffer.toString('utf8', offset, offset + namespaceKeyLength)\n      : ''\n    offset += namespaceKeyLength\n\n    /**\n     * Finally, the keys\n     */\n    const keys = []\n    while (offset < buffer.length) {\n      /**\n       * First 4 bytes are the length of the key in bytes\n       */\n      const keyLength = buffer.readUInt32BE(offset)\n      offset += 4\n\n      /**\n       * Then comes the key itself\n       */\n      const key = buffer.toString('utf8', offset, offset + keyLength)\n      offset += keyLength\n\n      keys.push(key)\n    }\n\n    return { busId, payload: { keys, type, namespace } }\n  }\n}\n"],"mappings":"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","names":["result"]}