{"version":3,"sources":["../../tests/helpers/driver_test_suite.ts"],"sourcesContent":["/// <reference types=\"@japa/assert\" />\n\nimport { sleep } from '@julr/utils/misc'\nimport type { Group } from '@japa/runner/core'\nimport type { test as JapaTest } from '@japa/runner'\n\nimport type { CacheDriver, CacheDriverOptions } from '../../src/types/main.js'\n\nexport function registerCacheDriverTestSuite(options: {\n  test: typeof JapaTest\n  group: Group\n  createDriver: (options?: CacheDriverOptions) => CacheDriver<any>\n  configureGroup?: (group: Group) => any\n\n  /**\n   * If the driver support milliseconds for TTLs\n   */\n  supportsMilliseconds?: boolean\n}) {\n  const { test, group } = options\n\n  let cache: CacheDriver\n\n  group.setup(async () => {\n    cache = options.createDriver()\n    return () => cache.disconnect()\n  })\n\n  group.tap((t) => t.disableTimeout())\n  group.each.teardown(async () => {\n    await cache.clear()\n  })\n\n  options.configureGroup?.(group)\n\n  test('get() returns undefined when key does not exists', async ({ assert }) => {\n    assert.deepEqual(await cache.get('key'), undefined)\n  })\n\n  test('get() returns value', async ({ assert }) => {\n    await cache.set('key', 'value')\n    assert.deepEqual(await cache.get('key'), 'value')\n  })\n\n  test('set() store a value', async ({ assert }) => {\n    await cache.set('key', 'value')\n    assert.deepEqual(await cache.get('key'), 'value')\n  })\n\n  test('set() store a value with expiration', async ({ assert }) => {\n    await cache.delete('key')\n\n    await cache.set('key', 'value', 1500)\n    assert.deepEqual(await cache.get('key'), 'value')\n\n    await sleep(2500)\n    assert.deepEqual(await cache.get('key'), undefined)\n  })\n\n  test('set() returns true when value is set', async ({ assert }) => {\n    const result = await cache.set('key', 'value')\n    assert.isTrue(result)\n  })\n\n  test('clear() remove all keys', async ({ assert }) => {\n    await cache.set('key1', 'value1')\n    await cache.set('key2', 'value2', 60_000)\n\n    await cache.clear()\n\n    assert.deepEqual(await cache.get('key1'), undefined)\n    assert.deepEqual(await cache.get('key2'), undefined)\n  })\n\n  test('clear() remove only keys with prefix', async ({ assert, cleanup }) => {\n    const cache2 = options.createDriver({ prefix: 'prefix' })\n    cleanup(async () => {\n      await cache2.clear()\n      await cache2.disconnect()\n    })\n\n    await cache2.set('key1', 'value1')\n\n    await cache.clear()\n\n    assert.deepEqual(await cache2.get('key1'), 'value1')\n  })\n\n  test('delete() removes a key', async ({ assert }) => {\n    await cache.set('key1', 'value1')\n    await cache.delete('key1')\n    assert.deepEqual(await cache.get('key1'), undefined)\n  })\n\n  test('deleteMany() removes many keys', async ({ assert }) => {\n    await cache.set('key1', 'value1')\n    await cache.set('key2', 'value2')\n\n    await cache.deleteMany(['key1', 'key2'])\n\n    assert.deepEqual(await cache.get('key1'), undefined)\n    assert.deepEqual(await cache.get('key2'), undefined)\n  })\n\n  test('deleteMany() return true when no keys are provided', async ({ assert }) => {\n    const result = await cache.deleteMany([])\n    assert.isTrue(result)\n  })\n\n  test('delete() returns true when key is removed', async ({ assert }) => {\n    await cache.set('key1', 'value1')\n    const result = await cache.delete('key1')\n    assert.isTrue(result)\n  })\n\n  test('delete() returns false when key does not exists', async ({ assert }) => {\n    const result = await cache.delete('key1')\n    assert.isFalse(result)\n  })\n\n  test('pull() returns value and removes it', async ({ assert }) => {\n    await cache.set('key1', 'foo')\n    const value = await cache.pull('key1')\n    assert.deepEqual(value, 'foo')\n  })\n\n  test('pull() returns undefined when key does not exists', async ({ assert }) => {\n    const value = await cache.pull('key1')\n    assert.isUndefined(value)\n  })\n\n  test('namespace() returns a new instance', async ({ assert }) => {\n    const cache2 = cache.namespace('foo')\n    assert.notEqual(cache, cache2)\n  })\n\n  test('set() value on namespace', async ({ assert }) => {\n    const fooNamespace = cache.namespace('foo')\n\n    await fooNamespace.set('key1', 'value1')\n    assert.deepEqual(await cache.get('key1'), undefined)\n    assert.deepEqual(await fooNamespace.get('key1'), 'value1')\n  })\n\n  test('get() value from namespace', async ({ assert }) => {\n    const fooNamespace = cache.namespace('foo')\n\n    await cache.set('key1', 'value1')\n    await fooNamespace.set('key1', 'value2')\n\n    assert.deepEqual(await cache.get('key1'), 'value1')\n    assert.deepEqual(await fooNamespace.get('key1'), 'value2')\n  })\n\n  test('clear() should only clear namespaces items', async ({ assert }) => {\n    const fooNamespace = cache.namespace('foo')\n\n    await cache.set('key1', 'value1')\n    await fooNamespace.set('key2', 'value2')\n\n    await fooNamespace.clear()\n    assert.deepEqual(await cache.get('key1'), 'value1')\n    assert.isUndefined(await fooNamespace.get('key2'))\n  })\n\n  test('clear() on root cache should clear namespaces items too', async ({ assert }) => {\n    const fooNamespace = cache.namespace('foo')\n\n    await cache.set('key1', 'value1')\n    await fooNamespace.set('key2', 'value2')\n\n    await cache.clear()\n\n    assert.isUndefined(await cache.get('key1'))\n    assert.isUndefined(await fooNamespace.get('key2'))\n  })\n\n  test('should be able to access namespaced key from root if prefixed', async ({ assert }) => {\n    const users = cache.namespace('users')\n    const usersPosts = users.namespace('posts')\n\n    await users.set('key1', 'value1')\n    await usersPosts.set('key1', 'value2')\n\n    const r1 = await cache.get('users:key1')\n    const r2 = await usersPosts.get('key1')\n    const r3 = await users.get('posts:key1')\n    const r4 = await cache.get('users:posts:key1')\n\n    assert.deepEqual(r1, 'value1')\n    assert.deepEqual(r2, 'value2')\n    assert.deepEqual(r3, 'value2')\n    assert.deepEqual(r4, 'value2')\n  })\n\n  test('namespace clear() should only clear prefixed keys', async ({ assert }) => {\n    const users = cache.namespace('users')\n\n    await cache.set('usersAbc', 'value1')\n    await users.set('abc', 'value2')\n\n    await users.clear()\n\n    const r1 = await cache.get('usersAbc')\n    const r2 = await users.get('abc')\n\n    assert.deepEqual(r1, 'value1')\n    assert.isUndefined(r2)\n  })\n}\n"],"mappings":"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","names":[]}