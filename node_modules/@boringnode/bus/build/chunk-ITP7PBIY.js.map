{"version":3,"sources":["../src/types/main.ts"],"sourcesContent":["/**\n * @boringnode/bus\n *\n * @license MIT\n * @copyright BoringNode\n */\n\nimport type { RedisOptions } from 'ioredis'\nimport type { IClientOptions } from 'mqtt'\nexport type TransportFactory = () => Transport\n\n/**\n * A Duration can be a number in milliseconds or a string formatted as a duration\n *\n * Formats accepted are :\n * - Simple number in milliseconds\n * - String formatted as a duration. Uses https://github.com/lukeed/ms under the hood\n */\nexport type Duration = number | string\n\nexport interface ManagerConfig<KnownTransports extends Record<string, TransportConfig>> {\n  default?: keyof KnownTransports\n  transports: KnownTransports\n}\n\nexport interface TransportConfig {\n  transport: TransportFactory\n  retryQueue?: RetryQueueOptions\n}\n\nexport interface RedisTransportConfig extends RedisOptions {\n  /**\n   * If true, we will use `messageBuffer` event instead of `message` event\n   * that is emitted by ioredis. `messageBuffer` will returns a buffer instead\n   * of a string and this is useful when you are dealing with binary data.\n   */\n  useMessageBuffer?: boolean\n}\n\nexport enum MqttProtocol {\n  MQTT = 'mqtt',\n  MQTTS = 'mqtts',\n  TCP = 'tcp',\n  TLS = 'tls',\n  WS = 'ws',\n  WSS = 'wss',\n  WXS = 'wxs',\n  ALIS = 'alis',\n}\n\nexport interface MqttTransportConfig {\n  host: string\n  port?: number\n  protocol?: MqttProtocol\n  options?: IClientOptions\n}\n\nexport interface Transport {\n  setId: (id: string) => Transport\n  onReconnect: (callback: () => void) => void\n  publish: (channel: string, message: Serializable) => Promise<void>\n  subscribe: <T extends Serializable>(\n    channel: string,\n    handler: SubscribeHandler<T>\n  ) => Promise<void>\n  unsubscribe: (channel: string) => Promise<void>\n  disconnect: () => Promise<void>\n}\n\nexport interface TransportMessage<T extends Serializable = any> {\n  busId: string\n  payload: T\n}\n\nexport interface TransportEncoder {\n  encode: (message: TransportMessage) => string | Buffer\n  decode: <T>(data: string | Buffer) => { busId: string; payload: T }\n}\n\nexport interface RetryQueueOptions {\n  enabled?: boolean\n  removeDuplicates?: boolean\n  maxSize?: number | null\n  retryInterval?: Duration | false\n}\n\nexport type SubscribeHandler<T extends Serializable> = (payload: T) => void | Promise<void>\n\nexport type Serializable =\n  | string\n  | number\n  | boolean\n  | null\n  | Serializable[]\n  | { [key: string]: Serializable }\n"],"mappings":";AAuCO,IAAK,eAAL,kBAAKA,kBAAL;AACL,EAAAA,cAAA,UAAO;AACP,EAAAA,cAAA,WAAQ;AACR,EAAAA,cAAA,SAAM;AACN,EAAAA,cAAA,SAAM;AACN,EAAAA,cAAA,QAAK;AACL,EAAAA,cAAA,SAAM;AACN,EAAAA,cAAA,SAAM;AACN,EAAAA,cAAA,UAAO;AARG,SAAAA;AAAA,GAAA;","names":["MqttProtocol"]}