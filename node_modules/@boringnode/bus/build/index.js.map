{"version":3,"sources":["../src/bus.ts","../src/retry_queue_with_duplicates.ts","../src/message_hasher.ts","../src/retry_queue_without_duplicates.ts","../src/retry_queue.ts","../src/bus_manager.ts","../src/define_config.ts"],"sourcesContent":["/**\n * @boringnode/bus\n *\n * @license MIT\n * @copyright BoringNode\n */\n\nimport string from '@poppinss/utils/string'\nimport { createId } from '@paralleldrive/cuid2'\nimport { RetryQueue } from './retry_queue.js'\nimport debug from './debug.js'\nimport type { RetryQueueOptions, Serializable, SubscribeHandler, Transport } from './types/main.js'\n\nexport class Bus {\n  readonly #transport: Transport\n  readonly #busId: string\n  readonly #errorRetryQueue: RetryQueue\n  readonly #retryQueueInterval: NodeJS.Timeout | undefined\n\n  constructor(transport: Transport, options?: { retryQueue?: RetryQueueOptions }) {\n    this.#transport = transport\n    this.#busId = createId()\n    this.#errorRetryQueue = new RetryQueue(options?.retryQueue)\n\n    if (options?.retryQueue?.retryInterval) {\n      const intervalValue =\n        typeof options?.retryQueue?.retryInterval === 'number'\n          ? options?.retryQueue?.retryInterval\n          : string.milliseconds.parse(options?.retryQueue?.retryInterval)\n\n      this.#retryQueueInterval = setInterval(() => {\n        void this.processErrorRetryQueue()\n      }, intervalValue)\n    }\n\n    transport.setId(this.#busId).onReconnect(() => this.#onReconnect())\n  }\n\n  getRetryQueue() {\n    return this.#errorRetryQueue\n  }\n\n  processErrorRetryQueue() {\n    debug(`start error retry queue processing with ${this.#errorRetryQueue.size()} messages`)\n\n    return this.#errorRetryQueue.process(async (channel, message) => {\n      return await this.publish(channel, message.payload)\n    })\n  }\n\n  async #onReconnect() {\n    debug(`bus transport ${this.#transport.constructor.name} reconnected`)\n\n    await this.processErrorRetryQueue()\n  }\n\n  subscribe<T extends Serializable>(channel: string, handler: SubscribeHandler<T>) {\n    debug(`subscribing to channel ${channel}`)\n\n    return this.#transport.subscribe(channel, async (message) => {\n      debug('received message %j from bus', message)\n      // @ts-expect-error - TODO: Weird typing issue\n      handler(message)\n    })\n  }\n\n  async publish(channel: string, message: Serializable) {\n    try {\n      debug('publishing message \"%j\" to channel \"%s\"', message, channel)\n\n      await this.#transport.publish(channel, message)\n\n      return true\n    } catch (error) {\n      debug('error publishing message \"%j\" to channel \"%s\". Retrying later', message, channel)\n\n      const wasAdded = this.#errorRetryQueue.enqueue(channel, {\n        payload: message,\n        busId: this.#busId,\n      })\n\n      if (!wasAdded) return false\n\n      debug(`added message %j to error retry queue`, message)\n      return false\n    }\n  }\n\n  disconnect() {\n    if (this.#retryQueueInterval) {\n      clearInterval(this.#retryQueueInterval)\n    }\n\n    return this.#transport.disconnect()\n  }\n\n  unsubscribe(channel: string) {\n    return this.#transport.unsubscribe(channel)\n  }\n}\n","/**\n * @boringnode/bus\n *\n * @license MIT\n * @copyright BoringNode\n */\n\nimport type { TransportMessage, RetryQueueOptions } from './types/main.js'\n\nexport class RetryQueueWithDuplicates {\n  #queue = new Set<{ channel: string; message: TransportMessage }>()\n\n  readonly #enabled: boolean\n  readonly #maxSize: number | null\n\n  constructor(params: RetryQueueOptions = {}) {\n    const { enabled = true, maxSize = null } = params\n\n    this.#enabled = enabled\n    this.#maxSize = maxSize\n  }\n\n  size() {\n    return this.#queue.size\n  }\n\n  async process(handler: (channel: string, message: TransportMessage) => Promise<boolean>) {\n    if (!this.#enabled) return\n\n    for (const { channel, message } of this.#queue) {\n      const result = await handler(channel, message).catch(() => false)\n\n      if (!result) {\n        break\n      }\n\n      this.dequeue()\n    }\n  }\n\n  enqueue(channel: string, message: TransportMessage) {\n    if (!this.#enabled) return false\n\n    if (this.#maxSize && this.#queue.size >= this.#maxSize) {\n      this.dequeue()\n    }\n\n    this.#queue.add({ channel, message })\n\n    return true\n  }\n\n  dequeue() {\n    if (!this.#enabled) return\n\n    const [first] = this.#queue\n\n    if (first) {\n      this.#queue.delete(first)\n\n      return first.message\n    }\n  }\n}\n","/**\n * @boringnode/bus\n *\n * @license MIT\n * @copyright BoringNode\n */\n\nimport hash from 'object-hash'\nimport type { Serializable } from './types/main.js'\n\nexport class MessageHasher {\n  hash(value: Serializable): string {\n    return hash(value, { algorithm: 'sha1', encoding: 'base64' })\n  }\n}\n","/**\n * @boringnode/bus\n *\n * @license MIT\n * @copyright BoringNode\n */\n\nimport { MessageHasher } from './message_hasher.js'\nimport type { TransportMessage, RetryQueueOptions } from './types/main.js'\n\nexport class RetryQueueWithoutDuplicates {\n  #queue = new Map<string, { channel: string; message: TransportMessage }>()\n  #messageHasher: MessageHasher\n\n  readonly #enabled: boolean\n  readonly #maxSize: number | null\n\n  constructor(params: RetryQueueOptions = {}) {\n    const { enabled = true, maxSize = null } = params\n\n    this.#enabled = enabled\n    this.#maxSize = maxSize\n    this.#messageHasher = new MessageHasher()\n  }\n\n  #generateMessageHash(message: TransportMessage) {\n    return this.#messageHasher.hash(message.payload)\n  }\n\n  size() {\n    return this.#queue.size\n  }\n\n  async process(handler: (channel: string, message: TransportMessage) => Promise<boolean>) {\n    if (!this.#enabled) return\n\n    for (const { channel, message } of this.#queue.values()) {\n      const result = await handler(channel, message).catch(() => false)\n\n      if (!result) {\n        break\n      }\n\n      this.dequeue()\n    }\n  }\n\n  enqueue(channel: string, message: TransportMessage) {\n    if (!this.#enabled) return false\n\n    if (this.#maxSize && this.#queue.size >= this.#maxSize) {\n      this.dequeue()\n    }\n\n    const hash = this.#generateMessageHash(message)\n\n    if (this.#queue.has(hash)) {\n      return false\n    }\n\n    this.#queue.set(hash, { channel, message })\n\n    return true\n  }\n\n  dequeue() {\n    if (!this.#enabled) return\n\n    const { message } = this.#queue.values().next().value\n\n    if (message) {\n      this.#queue.delete(this.#generateMessageHash(message))\n\n      return message\n    }\n  }\n}\n","/**\n * @boringnode/bus\n *\n * @license MIT\n * @copyright BoringNode\n */\n\nimport { RetryQueueWithDuplicates } from './retry_queue_with_duplicates.js'\nimport { RetryQueueWithoutDuplicates } from './retry_queue_without_duplicates.js'\nimport type { TransportMessage, RetryQueueOptions } from './types/main.js'\n\nexport class RetryQueue {\n  readonly #options: RetryQueueOptions\n  readonly #queue: RetryQueueWithDuplicates | RetryQueueWithoutDuplicates\n\n  constructor(params: RetryQueueOptions = {}) {\n    const { enabled = true, maxSize = null, removeDuplicates = true } = params\n\n    this.#options = { enabled, maxSize, removeDuplicates }\n\n    if (removeDuplicates) {\n      this.#queue = new RetryQueueWithoutDuplicates({ enabled, maxSize })\n      return\n    }\n\n    this.#queue = new RetryQueueWithDuplicates({ enabled, maxSize })\n  }\n\n  getOptions() {\n    return this.#options\n  }\n\n  getInternalQueue() {\n    return this.#queue\n  }\n\n  size() {\n    return this.#queue.size()\n  }\n\n  async process(handler: (channel: string, message: TransportMessage) => Promise<boolean>) {\n    return this.#queue.process(handler)\n  }\n\n  enqueue(channel: string, message: TransportMessage) {\n    return this.#queue.enqueue(channel, message)\n  }\n\n  dequeue() {\n    this.#queue.dequeue()\n  }\n}\n","/**\n * @boringnode/bus\n *\n * @license MIT\n * @copyright BoringNode\n */\n\nimport { RuntimeException } from '@poppinss/utils/exceptions'\nimport { Bus } from './bus.js'\nimport debug from './debug.js'\nimport type {\n  ManagerConfig,\n  Serializable,\n  SubscribeHandler,\n  TransportConfig,\n} from './types/main.js'\n\nexport class BusManager<KnownTransports extends Record<string, TransportConfig>> {\n  readonly #defaultTransportName: keyof KnownTransports | undefined\n  readonly #transports: KnownTransports\n\n  #transportsCache: Partial<Record<keyof KnownTransports, Bus>> = {}\n\n  constructor(config: ManagerConfig<KnownTransports>) {\n    debug('creating bus manager. config: %O', config)\n\n    this.#transports = config.transports\n    this.#defaultTransportName = config.default\n  }\n\n  use<KnownTransport extends keyof KnownTransports>(transports?: KnownTransport): Bus {\n    let transportToUse: keyof KnownTransports | undefined = transports || this.#defaultTransportName\n\n    if (!transportToUse) {\n      throw new RuntimeException(\n        'Cannot create bus instance. No default transport is defined in the config'\n      )\n    }\n\n    const cachedTransport = this.#transportsCache[transportToUse]\n    if (cachedTransport) {\n      debug('returning cached transport instance for %s', transportToUse)\n      return cachedTransport\n    }\n\n    const transportConfig = this.#transports[transportToUse]\n\n    debug('creating new transport instance for %s', transportToUse)\n    const transportInstance = new Bus(transportConfig.transport(), {\n      retryQueue: transportConfig.retryQueue,\n    })\n    this.#transportsCache[transportToUse] = transportInstance\n\n    return transportInstance\n  }\n\n  async publish(channel: string, message: Serializable) {\n    return this.use().publish(channel, message)\n  }\n\n  subscribe<T extends Serializable>(channel: string, handler: SubscribeHandler<T>) {\n    return this.use().subscribe(channel, handler)\n  }\n\n  unsubscribe(channel: string) {\n    return this.use().unsubscribe(channel)\n  }\n\n  disconnect() {\n    return this.use().disconnect()\n  }\n}\n","/**\n * @boringnode/bus\n *\n * @license MIT\n * @copyright BoringNode\n */\n\nimport type { ManagerConfig, TransportConfig } from './types/main.js'\n\nexport function defineConfig<KnownTransports extends Record<string, TransportConfig>>(\n  config: ManagerConfig<KnownTransports>\n): ManagerConfig<KnownTransports> {\n  return config\n}\n"],"mappings":"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","names":["hash"]}