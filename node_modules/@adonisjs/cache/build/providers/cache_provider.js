import "../chunk-EUXUH3YW.js";

// src/bindings/repl.ts
function setupReplState(repl, key, value) {
  repl.server.context[key] = value;
  repl.notify(
    `Loaded ${key} module. You can access it using the "${repl.colors.underline(key)}" variable`
  );
}
function defineReplBindings(app, Repl) {
  Repl.addMethod(
    "loadCache",
    async (repl) => setupReplState(repl, "cache", await app.container.make("cache.manager")),
    { description: 'Load cache provider to the "cache" property' }
  );
}

// src/debug.ts
import { debuglog } from "node:util";
var debug_default = debuglog("adonisjs:cache");

// src/bindings/edge.ts
async function registerViewBindings(manager) {
  const edge = await import("edge.js");
  debug_default("detected edge installation. Registering cache global helpers");
  edge.default.global("cache", manager);
}

// providers/cache_provider.ts
var CacheProvider = class {
  constructor(app) {
    this.app = app;
  }
  /**
   * Register the cache manager to the container
   */
  async #registerCacheManager() {
    const cacheConfig = this.app.config.get("cache");
    this.app.container.singleton("cache.manager", async () => {
      const { BentoCache } = await import("bentocache");
      const emitter = await this.app.container.make("emitter");
      const resolvedStores = Object.entries(cacheConfig.stores).map(async ([name, store]) => {
        return [name, await store.entry().resolver(this.app)];
      });
      return new BentoCache({
        ...cacheConfig,
        emitter,
        default: cacheConfig.default,
        stores: Object.fromEntries(await Promise.all(resolvedStores))
      });
    });
  }
  /**
   * Register REPL bindings
   */
  async #registerReplBindings() {
    if (this.app.getEnvironment() !== "repl") {
      return;
    }
    const repl = await this.app.container.make("repl");
    defineReplBindings(this.app, repl);
  }
  /**
   * Register edge bindings
   */
  async #registerEdgeBindings() {
    if (!this.app.usingEdgeJS) return;
    const manager = await this.app.container.make("cache.manager");
    await registerViewBindings(manager);
  }
  /**
   * Register bindings
   */
  async register() {
    await this.#registerCacheManager();
    await this.#registerReplBindings();
    await this.#registerEdgeBindings();
  }
  /**
   * Gracefully shutdown connections when app goes down
   */
  async shutdown() {
    try {
      const cache = await this.app.container.make("cache.manager");
      await cache.disconnectAll();
    } catch (_e) {
    }
  }
};
export {
  CacheProvider as default
};
//# sourceMappingURL=cache_provider.js.map