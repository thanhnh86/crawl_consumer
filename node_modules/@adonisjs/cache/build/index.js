import "./chunk-EUXUH3YW.js";

// index.ts
export * from "bentocache";

// src/store.ts
import { bentostore } from "bentocache";
import { configProvider } from "@adonisjs/core";
function store(options) {
  return new Store(options);
}
var Store = class {
  #baseOptions = {};
  #l1;
  #l2;
  #bus;
  constructor(baseOptions = {}) {
    this.#baseOptions = baseOptions;
  }
  /**
   * Add a L1 layer to your store. This is usually a memory driver
   * for fast access purposes.
   */
  useL1Layer(driver) {
    this.#l1 = driver;
    return this;
  }
  /**
   * Add a L2 layer to your store. This is usually something
   * distributed like Redis, DynamoDB, Sql database, etc.
   */
  useL2Layer(driver) {
    this.#l2 = driver;
    return this;
  }
  /**
   * Add a bus to your store. It will be used to synchronize L1 layers between
   * different instances of your application.
   */
  useBus(bus) {
    this.#bus = bus;
    return this;
  }
  /**
   * Create a config provider for the store
   */
  entry() {
    return configProvider.create(async (app) => {
      const storeInstance = bentostore(this.#baseOptions);
      if (this.#l1) storeInstance.useL1Layer(await this.#l1?.resolver(app));
      if (this.#l2) storeInstance.useL2Layer(await this.#l2?.resolver(app));
      if (this.#bus) storeInstance.useBus(await this.#bus?.resolver(app));
      return storeInstance;
    });
  }
};

// stubs/main.ts
import { dirname } from "node:path";
import { fileURLToPath } from "node:url";
var stubsRoot = dirname(fileURLToPath(import.meta.url));

// configure.ts
var DRIVERS_INFO = {
  file: {},
  redis: {},
  database: {},
  dynamodb: {
    envValidations: {
      AWS_ACCESS_KEY_ID: `Env.schema.string()`,
      AWS_SECRET_ACCESS_KEY: `Env.schema.string()`,
      AWS_REGION: `Env.schema.string()`,
      DYNAMODB_ENDPOINT: `Env.schema.string()`
    },
    envVars: {
      AWS_ACCESS_KEY_ID: "",
      AWS_SECRET_ACCESS_KEY: "",
      AWS_REGION: "",
      DYNAMODB_ENDPOINT: ""
    }
  }
};
async function configure(command) {
  const driver = await command.prompt.choice(
    "Select the cache driver you plan to use",
    ["redis", "file", "database", "dynamodb"],
    {
      hint: "You can always change it later"
    }
  );
  const codemods = await command.createCodemods();
  await codemods.updateRcFile((rcFile) => {
    rcFile.addProvider("@adonisjs/cache/cache_provider").addCommand("@adonisjs/cache/commands");
  });
  const { envVars, envValidations } = DRIVERS_INFO[driver];
  if (envVars) {
    await codemods.defineEnvVariables(envVars);
  }
  if (envValidations) {
    await codemods.defineEnvValidations({ variables: envValidations });
  }
  await codemods.makeUsingStub(stubsRoot, "config.stub", { driver });
}

// src/define_config.ts
function defineConfig(config) {
  return config;
}

// src/drivers.ts
import { configProvider as configProvider2 } from "@adonisjs/core";
import { RuntimeException } from "@adonisjs/core/exceptions";
var drivers = {
  /**
   * Redis driver for L2 layer
   * You must install @adonisjs/redis to use this driver
   */
  redis(config) {
    return configProvider2.create(async (app) => {
      const redis = await app.container.make("redis");
      const { redisDriver } = await import("bentocache/drivers/redis");
      const redisConnection = redis.connection(config.connectionName);
      return redisDriver({ connection: redisConnection.ioConnection });
    });
  },
  /**
   * Redis driver for the sync bus
   * You must install @adonisjs/redis to use this driver
   */
  redisBus(config) {
    return configProvider2.create(async (app) => {
      const redis = await app.container.make("redis");
      const { redisBusDriver } = await import("bentocache/drivers/redis");
      const redisConnection = redis.connection(config.connectionName);
      return redisBusDriver({ connection: redisConnection.ioConnection.options });
    });
  },
  /**
   * Memory driver for L1 layer
   */
  memory(config) {
    return configProvider2.create(async () => {
      const { memoryDriver } = await import("bentocache/drivers/memory");
      return memoryDriver(config);
    });
  },
  /**
   * Database driver for L2 layer
   * You must install @adonisjs/lucid to use this driver
   */
  database(config) {
    return configProvider2.create(async (app) => {
      const db = await app.container.make("lucid.db");
      const connectionName = config?.connectionName || db.primaryConnectionName;
      const connection = db.manager.get(connectionName);
      if (!connection) {
        throw new RuntimeException(
          `Invalid connection name "${connectionName}" referenced by "config/cache.ts" file. First register the connection inside "config/database.ts" file`
        );
      }
      const { knexDriver } = await import("bentocache/drivers/knex");
      return knexDriver({ connection: db.connection(connectionName).getWriteClient() });
    });
  },
  /**
   * DynamoDB driver for L2 layer
   * You must install @aws-sdk/client-dynamodb to use this driver
   */
  dynamodb(config) {
    return configProvider2.create(async () => {
      const { dynamoDbDriver } = await import("bentocache/drivers/dynamodb");
      return dynamoDbDriver(config);
    });
  },
  /**
   * File driver for L2 layer
   */
  file(config) {
    return configProvider2.create(async () => {
      const { fileDriver } = await import("bentocache/drivers/file");
      return fileDriver(config);
    });
  },
  /**
   * Kysely driver for L2 layer
   */
  kysely(config) {
    return configProvider2.create(async () => {
      const { kyselyDriver } = await import("bentocache/drivers/kysely");
      return kyselyDriver(config);
    });
  },
  /**
   * Orchid driver for L2 layer
   */
  orchid(config) {
    return configProvider2.create(async () => {
      const { orchidDriver } = await import("bentocache/drivers/orchid");
      return orchidDriver(config);
    });
  }
};
export {
  configure,
  defineConfig,
  drivers,
  store
};
//# sourceMappingURL=index.js.map