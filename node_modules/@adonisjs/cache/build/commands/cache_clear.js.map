{"version":3,"sources":["../../commands/cache_clear.ts"],"sourcesContent":["/*\n * @adonisjs/cache\n *\n * (c) AdonisJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { args, BaseCommand, flags } from '@adonisjs/core/ace'\n\nimport { CacheService } from '../src/types.js'\nimport { CommandOptions } from '@adonisjs/core/types/ace'\n\nexport default class CacheClear extends BaseCommand {\n  static commandName = 'cache:clear'\n  static description = 'Clear the application cache'\n  static options: CommandOptions = {\n    startApp: true,\n  }\n\n  /**\n   * Choose a custom cache store to clear. Otherwise, we use the\n   * default one\n   */\n  @args.string({ description: 'Define a custom cache store to clear', required: false })\n  declare store: string\n\n  /**\n   * Optionally select a namespace to clear. Defaults to the whole cache.\n   */\n  @flags.string({ description: 'Select a cache namespace to clear', alias: 'n' })\n  declare namespace: string\n\n  /**\n   * Prompts to take consent when clearing the cache in production\n   */\n  async #takeProductionConsent(): Promise<boolean> {\n    const question = 'You are in production environment. Want to continue clearing the cache?'\n    try {\n      return await this.prompt.confirm(question)\n    } catch (error) {\n      return false\n    }\n  }\n\n  /**\n   * Check if the given cache exist\n   */\n  #cacheExists(cache: CacheService, cacheName: string) {\n    try {\n      cache.use(cacheName)\n      return true\n    } catch (error) {\n      return false\n    }\n  }\n\n  /**\n   * Handle command\n   */\n  async run() {\n    const cache = await this.app.container.make('cache.manager')\n    this.store = this.store || cache.defaultStoreName\n\n    /**\n     * Exit if cache store doesn't exist\n     */\n    if (!this.#cacheExists(cache, this.store)) {\n      this.logger.error(\n        `\"${this.store}\" is not a valid cache store. Double check config/cache.ts file`\n      )\n      this.exitCode = 1\n      return\n    }\n\n    /**\n     * Take consent when clearing the cache in production\n     */\n    if (this.app.inProduction) {\n      const shouldClear = await this.#takeProductionConsent()\n      if (!shouldClear) return\n    }\n\n    /**\n     * Finally clear the cache\n     */\n    const cacheHandler = cache.use(this.store)\n    if (this.namespace) {\n      await cacheHandler.namespace(this.namespace).clear()\n      this.logger.success(\n        `Cleared namespace \"${this.namespace}\" for \"${this.store}\" cache successfully`\n      )\n    } else {\n      await cacheHandler.clear()\n      this.logger.success(`Cleared \"${this.store}\" cache successfully`)\n    }\n  }\n}\n"],"mappings":";;;;;AASA,SAAS,MAAM,aAAa,aAAa;AAKzC,IAAqB,aAArB,cAAwC,YAAY;AAAA,EAClD,OAAO,cAAc;AAAA,EACrB,OAAO,cAAc;AAAA,EACrB,OAAO,UAA0B;AAAA,IAC/B,UAAU;AAAA,EACZ;AAAA;AAAA;AAAA;AAAA,EAkBA,MAAM,yBAA2C;AAC/C,UAAM,WAAW;AACjB,QAAI;AACF,aAAO,MAAM,KAAK,OAAO,QAAQ,QAAQ;AAAA,IAC3C,SAAS,OAAO;AACd,aAAO;AAAA,IACT;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,aAAa,OAAqB,WAAmB;AACnD,QAAI;AACF,YAAM,IAAI,SAAS;AACnB,aAAO;AAAA,IACT,SAAS,OAAO;AACd,aAAO;AAAA,IACT;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,MAAM;AACV,UAAM,QAAQ,MAAM,KAAK,IAAI,UAAU,KAAK,eAAe;AAC3D,SAAK,QAAQ,KAAK,SAAS,MAAM;AAKjC,QAAI,CAAC,KAAK,aAAa,OAAO,KAAK,KAAK,GAAG;AACzC,WAAK,OAAO;AAAA,QACV,IAAI,KAAK,KAAK;AAAA,MAChB;AACA,WAAK,WAAW;AAChB;AAAA,IACF;AAKA,QAAI,KAAK,IAAI,cAAc;AACzB,YAAM,cAAc,MAAM,KAAK,uBAAuB;AACtD,UAAI,CAAC,YAAa;AAAA,IACpB;AAKA,UAAM,eAAe,MAAM,IAAI,KAAK,KAAK;AACzC,QAAI,KAAK,WAAW;AAClB,YAAM,aAAa,UAAU,KAAK,SAAS,EAAE,MAAM;AACnD,WAAK,OAAO;AAAA,QACV,sBAAsB,KAAK,SAAS,UAAU,KAAK,KAAK;AAAA,MAC1D;AAAA,IACF,OAAO;AACL,YAAM,aAAa,MAAM;AACzB,WAAK,OAAO,QAAQ,YAAY,KAAK,KAAK,sBAAsB;AAAA,IAClE;AAAA,EACF;AACF;AAxEU;AAAA,EADP,KAAK,OAAO,EAAE,aAAa,wCAAwC,UAAU,MAAM,CAAC;AAAA,GAXlE,WAYX;AAMA;AAAA,EADP,MAAM,OAAO,EAAE,aAAa,qCAAqC,OAAO,IAAI,CAAC;AAAA,GAjB3D,WAkBX;","names":[]}